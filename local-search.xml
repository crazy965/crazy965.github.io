<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Android NDK指南</title>
    <link href="/2025/01/15/Android-NDK%E6%8C%87%E5%8D%97/"/>
    <url>/2025/01/15/Android-NDK%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<blockquote><p>网络上的NDK文章，备份到本地， 原文地址 <a href="https://l0neman.github.io/2020/07/14/android-ndk-%E6%8C%87%E5%8D%97/#CMake-1">l0neman.github.io</a></p></blockquote><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><blockquote><p>前言编写此文档的用意： </p><p>作为搭建基础 NDK 工程的教程； 作为入门 NDK 工程的参考手册。</p></blockquote><p>编写此文档的用意：</p><ol><li>作为搭建基础 NDK 工程的教程；</li><li>作为入门 NDK 工程的参考手册。</li></ol><h2 id="2-NDK-工程构建"><a href="#2-NDK-工程构建" class="headerlink" title="2. NDK 工程构建"></a>2. NDK 工程构建</h2><p>可采用三种方式进行 NDK 工程的构建：</p><ol><li>基于 Make 的 ndk-build，这是传统的 ndk-build 构建方式，使用 Makefile 方式进行构建，简洁高效；</li><li>CMake 是新型的构建方式，CMake 具有跨平台的特性，通过 CMake 生成 Makefile 后再进行构建，CMake 的配置文件可读性更高；</li><li>其他编译系统，通过引入其他编译系统可对编译过程进行定制，例如引入 obfuscator-llvm 对源码进行混淆和压缩，增强源代码安全性。</li></ol><p>下面是每种构建方式的基础示例，使用 Android Studio 4.0 和 NDK 21 进行如下构建。</p><h3 id="2-1-Android-mk"><a href="#2-1-Android-mk" class="headerlink" title="2.1 Android.mk"></a>2.1 Android.mk</h3><p>基于 Android.mk 的产物为 libfoo.so 的 NDK 基本工程搭建。</p><p>在 Android 工程的 src&#x2F;main 下建立 jni 目录（Android.mk 工程的默认文件目录为 jni，也可指定其他目录进行构建，使用命令 <code>ndk-build -C 目录</code>），工程结构如下：</p><p>包含两个 .mk 文件用来描述 NDK 工程，和两个基本的 C++ 语言源文件，结构如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">src/main<br> |<br> +-- java<br> +-- jni<br>      |<br>      +-- Android.mk<br>      +-- Application.mk<br>      +-- libfoo.h<br>      +-- libfoo.cpp<br></code></pre></td></tr></table></figure><p>在 Android Studio 的当前 Module 配置中指明 Android.mk 文件路径:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">android &#123;<br>  ...<br>  externalNativeBuild &#123;<br>    ndkBuild &#123;<br>      path <span class="hljs-string">&#x27;src/main/jni/Android.mk&#x27;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写 Android.mk 文件用于向 NDK 构建系统描述工程的 C&#x2F;C++ 源文件以及共享库的属性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">LOCAL_PATH := $(call my-dir)<br><br>include $(CLEAR_VARS)<br><br><br>LOCAL_MODULE := foo<br><br>LOCAL_SRC_FILES := libfoo.cpp<br><br>include $(BUILD_SHARED_LIBRARY)<br></code></pre></td></tr></table></figure><p>添加 Application.mk 用于描述 NDK 工程概要设置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">APP_ABI := armeabi-v7a arm64-v8a<br>APP_OPTIM := debug<br></code></pre></td></tr></table></figure><p>在 java 目录创建 Java 类，用于声明 JNI 方法，提供给其他类调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NativeHandler</span> &#123;<br><br>  <span class="hljs-type">static</span> &#123;<br>    <br>    System.<span class="hljs-built_in">loadLibrary</span>(<span class="hljs-string">&quot;foo&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> native String <span class="hljs-title">getHello</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>源代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> NDKTPROJECT_LIBFOO_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NDKTPROJECT_LIBFOO_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;jni.h&gt;</span></span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><br><br><span class="hljs-function">JNIEXPORT jstring JNICALL</span><br><span class="hljs-function"><span class="hljs-title">Java_io_l0neman_mkexample_NativeHandler_getHello</span><span class="hljs-params">(JNIEnv *env, jclass clazz)</span></span>;<br><br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;libfoo.h&quot;</span></span><br><br><span class="hljs-function">jstring <span class="hljs-title">Java_io_l0neman_mkexample_NativeHandler_getHello</span><span class="hljs-params">(JNIEnv *env, jclass clazz)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> env-&gt;<span class="hljs-built_in">NewStringUTF</span>(<span class="hljs-string">&quot;Hello-jni&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样的话就完成了一个基本的 NDK 工程搭建，编译后调用代码即可得到 java 字符串 <code>&quot;Hello-jni&quot;</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">String hello = NativeHandler.<span class="hljs-built_in">getHello</span>();<br></code></pre></td></tr></table></figure><ul><li>提示</li></ul><p>Android.mk 和 Application.mk 中可使用的系统变量请参考下文。</p><p>Android.mk 只是 Makefile 的片段，对于 Makefile 本身的熟悉有助于深入理解和编写 Android.mk，可参考 <a href="https://l0neman.github.io/2020/07/14/makefile-%E6%8C%87%E5%8D%97/">Makfile 指南</a></p><h3 id="2-2-CMake"><a href="#2-2-CMake" class="headerlink" title="2.2 CMake"></a>2.2 CMake</h3><p>使用 CMake 和 Android.mk 在 Android Studio 中的构建步骤类似，如下：</p><p>基于 CMake 的产出物为 libfoo.so 的 NDK 基本工程搭建。</p><p>在 Android 工程的 src&#x2F;main 下建立 cpp 目录，工程结构如下：</p><p>包含一个 CMakeLists.txt 文件来描述 NDK 工程，和两个基本的 C++ 语言文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">src/main<br> |<br> +-- java<br>     jni<br>      |<br>      +-- CMakeLists.txt<br>      +-- libfoo.h<br>      +-- libfoo.cpp<br></code></pre></td></tr></table></figure><p>在 Android Studio 的当前 Module 配置中指明 CMakeLists.txt 文件路径:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">android &#123;<br>  ...<br>  externalNativeBuild &#123;<br>    cmake &#123;<br>      path <span class="hljs-string">&#x27;src/main/cpp/CMakeLists.txt&#x27;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写 CMakeLists.txt 文件用于向 NDK 构建系统描述工程的 C&#x2F;C++ 源文件以及共享库的属性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.4</span><span class="hljs-number">.3</span>)<br><br><span class="hljs-built_in">add_library</span>(<br>        <br>        foo<br>        <br>        SHARED<br>        <br>        main.cpp<br>)<br></code></pre></td></tr></table></figure><p>此时将 Android.mk 工程中的 Java 源文件 NativeHandler.java 复制过来，将 libfoo.cpp 和 libfoo.h 内容填入中即可直接编译测试。</p><h3 id="2-3-独立工具链"><a href="#2-3-独立工具链" class="headerlink" title="2.3 独立工具链"></a>2.3 独立工具链</h3><p>有时编译 NDK 工程有一些特殊需求，例如对代码进行混淆，加入第三方编译器 obfuscator-llvm 对 NDK 工程进行编译。这时就需要搭建第三方工具链的编译环境，将它加入 NDK 的一般构建过程中。</p><p>下面是一个引入 obfuscator-llvm 编译器编译代码的示例。</p><h4 id="2-3-1-obfuscator-llvm-构建"><a href="#2-3-1-obfuscator-llvm-构建" class="headerlink" title="2.3.1 obfuscator-llvm 构建"></a>2.3.1 obfuscator-llvm 构建</h4><p>环境：android-ndk-r14b，目前已知此版本可支持 obfuscator-llvm 的编译配置</p><p>ndk r14b 下载地址：<a href="https://developer.android.google.cn/ndk/downloads/older_releases">https://developer.android.google.cn/ndk/downloads/older_releases</a></p><ul><li>首先下载编译器，指定最新版本的 obfuscator-llvm 分支，将仓库克隆至本地</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">git clone -b llvm<span class="hljs-number">-4.0</span> https:<span class="hljs-comment">//github.com/obfuscator-llvm/obfuscator.git</span><br></code></pre></td></tr></table></figure><ul><li>编译出编译器的可执行文件</li></ul><p>过程如下，以下命令 Windows DOS 和 Linux Shell 中可通用：</p><ol><li>进入编译器仓库目录中 <code>cd obfuscator</code>；</li><li>创建临时文件目录 <code>mkdir build</code>；</li><li>进入临时文件目录 <code>cd build</code>；</li><li>使用 CMake 生成 Makefile 或者 Vs 解决方案：</li></ol><p>如果没有按照 CMake，可去 CMake 官网下载安装。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cmake -DCMAKE_BUILD_TYPE=Release -DLLVM_INCLUDE_TESTS=OFF ../<br></code></pre></td></tr></table></figure><p>CMake 将会自动检测电脑上的编译器环境，如果是 Linux，生成 Makefile，如果 Windows 上安装了 Visual Studio，将生成解决方案文件。</p><ol start="5"><li>编译编译器源代码：</li></ol><p>Linux 上执行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">make -j4<br></code></pre></td></tr></table></figure><p>Windows 平台建议使用 Visual Studio 进行编译，直接打开 build 中的 LLVM.sln，然后生成解决方案（Build Solution）。</p><p>编译过程需要持续 30 分钟或更长时间，取决于电脑配置 CPU 性能。</p><p>编译过程中有可能出现错误，需要自己解决出现的不同情况，编译完成后将生成所需的 bin 和 lib 目录（Release 中）。</p><ul><li>配置 NDK 环境</li></ul><p>设原始 NDK 工具链根目录为 android-ndk-r14b。</p><p>进入 android-ndk-r14b&#x2F;toolchains 目录中，复制已存在的 llvm 目录到 ollvm-4.0，Linux 使用 <code>cp llvm ollvm-4.0</code>，Windows 复制文件出现 <code>llvm-副本</code> 后重命名为 <code>ollvm-4.0</code>。</p><p>Windows 平台将上面编译出来的 bin 和 lib 放入 ollvm-4.0&#x2F;prebuilt&#x2F;windows-x86_64 中，Linux 平台放入 ollvm-4.0&#x2F;prebuilt&#x2F;linux-x86_64 中，macOS 为 ollvm-4.0&#x2F;prebuilt&#x2F;darwin-x86_64。</p><p>进入 android-ndk-r14b&#x2F;build&#x2F;core&#x2F;toolchains 中，在当前目录复制出如下目录：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">arm-linux-androideabi-clang -&gt; arm-linux-androideabi-clang-ollvm<span class="hljs-number">4.0</span><br>aarch64-linux-android-clang -&gt; aarch64-linux-android-clang-ollvm<span class="hljs-number">4.0</span><br>x86-clang                   -&gt; x86-clang-ollvm<span class="hljs-number">4.0</span><br>x86_64-clang                -&gt; x86_64-clang-ollvm<span class="hljs-number">4.0</span><br></code></pre></td></tr></table></figure><p>修改复制后的两个目录中的 setup.mk 文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">android-ndk-r14b/build/core/toolchains/arm-linux-androideabi-clang-ollvm<span class="hljs-number">4.0</span>/setup.mk<br>android-ndk-r14b/build/core/toolchains/aarch64-linux-android-clang-ollvm<span class="hljs-number">4.0</span>/setup.mk<br>android-ndk-r14b/build/core/toolchains/arm-linux-androideabi-clang-ollvm<span class="hljs-number">4.0</span>/setup.mk<br>android-ndk-r14b/build/core/toolchains/x86_64-clang-ollvm<span class="hljs-number">4.0</span>/setup.mk<br></code></pre></td></tr></table></figure><p>将每个 <code>setup.mk</code> 中的如下内容：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">LLVM_TOOLCHAIN_PREBUILT_ROOT := $(call get-toolchain-root,llvm)<br></code></pre></td></tr></table></figure><p>替换为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">OLLVM_NAME := ollvm<span class="hljs-number">-4.0</span><br>LLVM_TOOLCHAIN_PREBUILT_ROOT := $(call get-toolchain-root,$(OLLVM_NAME))<br></code></pre></td></tr></table></figure><p>此时使用 ndk-build 将可以识别编译器。复制 4 个目录的原因是为了支持编译出每种 ABI，（armeabi、armeabi-v7a、arm64-v8a，x86、x86_64）。</p><ul><li>编译代码测试</li></ul><p>进入 NDK 工程中，修改 Application.mk 和 Android.mk 如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">APP_ABI := armeabi-v7a arm64-v8a<br><br>NDK_TOOLCHAIN_VERSION := clang-ollvm<span class="hljs-number">4.0</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp">LOCAL_PATH := $(call my-dir)<br><br>include $(CLEAR_VARS)<br><br>LOCAL_MODULE := foo<br>LOCAL_SRC_FILES := libfoo.cpp<br><br><br>LOCAL_CFLAGS += -mllvm -bcf -mllvm -bcf_loop=<span class="hljs-number">3</span> \<br>                -mllvm -fla -mllvm -split \<br>                -mllvm -sub -mllvm -sub_loop=<span class="hljs-number">3</span><br><br>include $(BUILD_SHARED_LIBRARY)<br></code></pre></td></tr></table></figure><p>在包含源代码的 jni 目录下执行配置好的 NDK r14b 中的 ndk-build 编译即可。</p><ul><li>验证结果</li></ul><p>编译后，在 libs 中将出现 ABI 目录，使用 IDA Pro 打开 libfoo.so，左侧 Functions windos 中找一个简单函数（例如 JNI_OnLoad）打开，发现程序逻辑流程已被混淆的面目全非。</p><p>左下角的 Graph overview 可以直观的看到整个函数的逻辑流程，非常复杂，无法直接了解到原始逻辑。</p><h3 id="2-4-构建技巧"><a href="#2-4-构建技巧" class="headerlink" title="2.4 构建技巧"></a>2.4 构建技巧</h3><h4 id="2-4-1-独立构建"><a href="#2-4-1-独立构建" class="headerlink" title="2.4.1 独立构建"></a>2.4.1 独立构建</h4><p>通常 NDK 构建过程需要依赖于 Android Studio 进行清理，构建等工作。</p><p>有时需要脱离 Android Studio，例如在无界面的服务器上独立构建，那么可以直接使用 <code>ndk-build</code> 命令行进行构建。</p><p>首先确认 NDK 的环境变量（将 NDK 工具链的根路径加入系统 PATH 变量）。然后直接在 jni 目录下打开终端（Windows 为 cmd），输入 <code>ndk-build clean</code>，将自动清理产生的 obj 文件和 libs 文件。</p><p>然后执行 <code>ndk-build</code> 即可构建出所需要的 so 文件，例如 libs&#x2F;arm64-v8a&#x2F;libfoo.so。</p><p>如果不想在 jni 目录中构建，可使用 <code>-C</code> 选项指定路径构建 <code>ndk-build -C jni_new</code>。</p><p>其他参数可参考官方文档：<a href="https://developer.android.google.cn/ndk/guides/ndk-build">https://developer.android.google.cn/ndk/guides/ndk-build</a></p><ul><li>提示</li></ul><p>对于普通 Android Studio 中的工程，也可以使用这种方法构建。</p><p>首先把 gradle 中 Android.mk 路径配置去除。在默认的依赖配置里面可以看到，libs 目录已被加入依赖，就是说如果 libs 目录中有 so 文件，那么会被自动加入 apk 中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">dependencies &#123;<br>    <span class="hljs-function">implementation <span class="hljs-title">fileTree</span><span class="hljs-params">(dir: <span class="hljs-string">&#x27;libs&#x27;</span>, include: [<span class="hljs-string">&#x27;*.jar&#x27;</span>])</span></span><br><span class="hljs-function">    ...</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><p>那么经过 <code>ndk-build</code> 构建后，可以直接运行 apk 工程，新的 libfoo.so 将被加入 apk 的 libs 目录中。</p><p>此时 Android Studio 构建和清理均不会影响 libs 中的 .so 文件，Java 代码和 NDK 开发代码可分别独立构建。</p><h4 id="2-4-2-快速部署"><a href="#2-4-2-快速部署" class="headerlink" title="2.4.2 快速部署"></a>2.4.2 快速部署</h4><p>对于一个主要由 native 代码构成的应用来说，修改 native 代码的动作较为频繁，如果每次都 clean 然后重新 build，再依赖于 Android studio 的运行安装会可能会比较麻烦。有时也需要依赖于其他 IDE 来构建 NDK 工程（例如使用 Visual Studio），那么可以采用如下方法：</p><p>首次构建 NDK 工程后安装运行到手机上，然后后面每次构建出 so，使用 adb 命令直接将 so 文件 push 到应用的沙盒目录下，重新启动应用进程即可使用新版的 so 文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">adb push libfoo.so /data/data/io.l0neman.mkexample/lib/<br></code></pre></td></tr></table></figure><p>注意 so 文件的架构应与当前应用采用的 ABI 对应。</p><p>不过这样做的前提是设备拥有 root 权限，也可直接使用官方的 Android 模拟器，选择下载带有 GoogleApis 的模拟器 ROM，输入如下命令即可获取 root 权限：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">adb root<br>adb remount<br></code></pre></td></tr></table></figure><p>之后 adb 将以 root 用户的身份运行。</p><h2 id="3-Android-mk-变量参考"><a href="#3-Android-mk-变量参考" class="headerlink" title="3. Android.mk 变量参考"></a>3. Android.mk 变量参考</h2><h3 id="3-1变量命名规范"><a href="#3-1变量命名规范" class="headerlink" title="3.1变量命名规范"></a>3.1变量命名规范</h3><p>NDK 构建系统保留了如下变量名称，在定义自己的变量时尽量避免这些规则：</p><ol><li>以 <code>LOCAL_</code> 开头的名称，例如 <code>LOCAL_MODULE</code>；</li><li>以 <code>PRIVATE_</code>、<code>NDK_</code> 或 <code>APP</code> 开头的名称，构建系统内部使用了这些变量名；</li><li>小写名称，例如 <code>my-dir</code>，构建系统内部使用了这些变量名。</li></ol><p>最好以 <code>MY_</code> 附加在自己的变量开头。</p><h3 id="3-2-NDK-定义的-include-变量"><a href="#3-2-NDK-定义的-include-变量" class="headerlink" title="3.2 NDK 定义的 include 变量"></a>3.2 NDK 定义的 include 变量</h3><ul><li>CLEAR_VARS</li></ul><p>此变量指向一个用于清理变量的脚本，当包含它时，会清理几乎所有的 <code>LOCAL_XXX</code> 变量，不包含 <code>LOCAL_PATH</code> 变量，一般在描述新模块之前包含。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">include $(CLEAR_VARS)<br></code></pre></td></tr></table></figure><ul><li>BUILD_EXECUTABLE</li></ul><p>指明构建的产出物是一个可执行文件（无文件后缀名），需要在源代码中包含一个 main 函数。通常构建可执行文件用来测试或用于其他调试工具。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argv, <span class="hljs-type">char</span> **args)</span> </span>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World!\n&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">include $(BUILD_EXECUTABLE)<br></code></pre></td></tr></table></figure><ul><li>BUILD_SHARED_LIBRARY</li></ul><p>指明构建的产出物是一个共享库（文件后缀为 .so），它会随着应用代码打包至 apk 中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">include $(BUILD_SHARED_LIBRARY)<br></code></pre></td></tr></table></figure><ul><li>BUILD_STATIC_LIBRARY</li></ul><p>指明构建的产出物是一个静态库（文件后缀为 .a），它不会被打包至 apk 中，只是为了被其他 native 模块引用。</p><ul><li>PREBUILT_SHARED_LIBRARY</li></ul><p>用于描述预编译共享库的构建，此时 <code>LOCAL_SRC_FILES</code> 变量指向预编译库的路径。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">LOCAL_SRC_FILES := $(TARGET_ARCH_ABI)/libbar.so<br>include $(PREBUILT_SHARED_LIBRARY)<br></code></pre></td></tr></table></figure><ul><li>PREBUILT_STATIC_LIBRARY</li></ul><p>用于描述预编译静态库的构建，此时 <code>LOCAL_SRC_FILES</code> 变量指向预编译库的路径。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">LOCAL_SRC_FILES := $(TARGET_ARCH_ABI)/libbar.a<br>include $(PREBUILT_STATIC_LIBRARY)<br></code></pre></td></tr></table></figure><h3 id="3-3-目标信息变量"><a href="#3-3-目标信息变量" class="headerlink" title="3.3 目标信息变量"></a>3.3 目标信息变量</h3><p>构建系统会根据 <code>APP_ABI</code> 变量（在 Application.mk 中定义）指定的每个 ABI 分别解析一次 Android.mk，如下变量将在构建系统每次解析时被重新定义值。</p><ul><li>TARGET_ARCH</li></ul><p>对应 CPU 系列，为 <code>arm</code>、<code>arm64</code>、<code>x86</code>、<code>x86_64</code>。</p><ul><li>TARGET_PLATFORM</li></ul><p>指向 Android API 级别号，例如 Android 5.1 对应 22。可以这样使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ifeq ($(TARGET_PLATFORM),android<span class="hljs-number">-22</span>)<br>    <br>endif<br></code></pre></td></tr></table></figure><ul><li>TARGET_ARCH_ABI</li></ul><p>对应每种 CPU 对应架构的 ABI。</p><table><thead><tr><th>CPU and architecture</th><th>Setting</th></tr></thead><tbody><tr><td>ARMv7</td><td>armeabi-v7a</td></tr><tr><td>ARMv8 AArch64</td><td>arm64-v8a</td></tr><tr><td>i6686</td><td>x86</td></tr><tr><td>x86-64</td><td>x86_64</td></tr></tbody></table><p>检查 ABI：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ifeq ($(TARGET_ARCH_ABI),arm64-v8a)<br>  <br>endif<br></code></pre></td></tr></table></figure><ul><li>TARGET_ABI</li></ul><p>目标 Android API 级别与 ABI 的串联值。检查在 Android API 级别 22 上运行的 64 位 ARM 设备：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ifeq ($(TARGET_ABI),android<span class="hljs-number">-22</span>-arm64-v8a)<br>  <br>endif<br></code></pre></td></tr></table></figure><h3 id="3-4-模块描述变量"><a href="#3-4-模块描述变量" class="headerlink" title="3.4 模块描述变量"></a>3.4 模块描述变量</h3><p>下面的变量用于向构建系统描述如可构建一个模块，每个模块都应遵守如下流程：</p><ol><li>使用 CLEAR_VARS 变量清理与上一个模块相关的变量；</li><li>为用于描述模块的变量赋值；</li><li>包含 BUILD_XXX 变量以适当的构建脚本用于该模块的构建。</li></ol><ul><li>LOCAL_PATH</li></ul><p>用于指定当前文件的路径，必须在 Android.mk 文件开头定义此变量。</p><p><code>CLEAR_VARS</code> 指向的脚本不会清除此变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">LOCAL_PATH := $(call my-dir)<br></code></pre></td></tr></table></figure><ul><li>LOCAL_MODULE</li></ul><p>用于向构建系统描述模块名称，对于 .so 和 .a 文件，系统会自动给名称添加 <code>lib</code> 前缀和文件扩展名。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">LOCAL_MODULE := foo<br></code></pre></td></tr></table></figure><ul><li>LOCAL_MODULE_FILENAME</li></ul><p>向构建系统描述模块的自定义名称，覆盖 <code>LOCAL_MODULE</code> 的名称。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">LOCAL_MODULE := foo<br><br>LOCAL_MODULE_FILENAME := libnewfoo<br></code></pre></td></tr></table></figure><ul><li>LOCAL_SRC_FILES</li></ul><p>向构建系统描述生成模块时所用的源文件列表，务必使用 Unix 样式的正斜杠 (&#x2F;) 来描述路径，且避免使用绝对路径。</p><ul><li>LOCAL_CPP_EXTENSION</li></ul><p>为 C++ 源文件指定除 .cpp 外的扩展名。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">LOCAL_CPP_EXTENSION := .cxx<br></code></pre></td></tr></table></figure><p>或指定多个：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">LOCAL_CPP_EXTENSION := .cxx .cpp .cc<br></code></pre></td></tr></table></figure><ul><li>LOCAL_CPP_FEATURES</li></ul><p>向构建系统指明代码所依赖于的特定 C++ 功能。避免使用 <code>LOCAL_CPPFLAGS</code> 声明，它会导致编译器将所有指定的标记用于所有模块。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">LOCAL_CPP_FEATURES := rtti<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">LOCAL_CPP_FEATURES := exceptions<br></code></pre></td></tr></table></figure><p>指定多个：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">LOCAL_CPP_FEATURES := rtti features<br></code></pre></td></tr></table></figure><ul><li>LOCAL_C_INCLUDES</li></ul><p>指定路径列表，以便在编译时添加到 include 搜索路径。搜索路径同时影响 ndk-gdb 调试路径。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">LOCAL_C_INCLUDES := sources/foo<br></code></pre></td></tr></table></figure><p>通过 <code>LOCAL_CFLAGS</code> 或 <code>LOCAL_CPPFLAGS</code> 设置任何对应的包含标记前定义此变量。</p><ul><li>LOCAL_CFLAGS</li></ul><p>构建 C 和 C++ 源文件时构建系统要传递的编译器标记，<code>LOCAL_CPPFLAGS</code> 可仅为 C++ 源文件指定标记。</p><p>相关：GCC 编译器选项参考 <a href="https://gcc.gnu.org/onlinedocs/gcc/C_002b_002b-Dialect-Options.html#C_002b_002b-Dialect-Options">https://gcc.gnu.org/onlinedocs/gcc/C_002b_002b-Dialect-Options.html#C_002b_002b-Dialect-Options</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">LOCAL_CFLAGS += -I&lt;path&gt;,<br></code></pre></td></tr></table></figure><ul><li>LOCAL_CPPFLAGS</li></ul><p>只构建 C++ 源文件传递的一组编译器标记，放在 <code>LOCAL_CFLAGS</code> 变量定义的后面。</p><ul><li>LOCAL_STATIC_LIBRARIES</li></ul><p>存储当前模块依赖的静态库模块列表</p><ol><li>如果当前模块是共享库或可执行文件，此变量强制这些库链接到生成的二进制文件；</li><li>如果当前模块是静态库，此变量指出依赖于当前模块的其他模块也会依赖于其列出的库。</li></ol><ul><li>LOCAL_SHARED_LIBRARIES</li></ul><p>此变量列出此模块在运行时依赖的共享库模块。用于将相应的连链接信息嵌入到生成的文件中。</p><ul><li>LOCAL_WHOLE_STATIC_LIBRARIES</li></ul><p><code>LOCAL_STATIC_LIBRARIES</code> 的变体形式，表示链接器应将相关的库模块视为完整归档（链接所有符号，而不只是用到的），<br>可参考 ld 链接器的 <code>--whole-archive</code> 选项。</p><ul><li>LOCAL_LDLIBS</li></ul><p>列出在构建共享库或可执行文件时使用的额外链接器标记，使用 <code>-l</code> 前缀来指明连接到特定系统库（一般用于链接 NDK 提供的公开系统库，例如 liblog）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">LOCAL_LDLIBS := -lz<br></code></pre></td></tr></table></figure><ul><li>LOCAL_LDFLAGS</li></ul><p>列出构建系统在构建共享库或可执行文件时使用的其他链接器标记。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">LOCAL_LDFLAGS += -fuse-ld=bfd<br></code></pre></td></tr></table></figure><p>定义静态库时，构建系统会忽略此变量，<code>ndk-build</code> 会打印警告。</p><ul><li>LOCAL_ALLOW_UNDEFINED_SYMBOLS</li></ul><p>默认情况下，构建系统在尝试构建共享库时遇到未定义的引用，将会抛出 “未定义的符号” 错误，指定此变量为 <code>true</code>，将停用此检查（可能会导致运行时加载）。</p><p>定义静态库时，构建系统会忽略此变量，<code>ndk-build</code> 会打印警告。</p><ul><li>LOCAL_ARM_MODE</li></ul><p>默认情况下，构建系统会以 thumb 模式生成 ARM 目标二进制文件，其中每条指令都是 16 位宽，并与 thumb&#x2F; 目录中的 STL 库链接。将此变量定义为 arm 会强制构建系统以 32 位 arm 模式生成模块的对象文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">LOCAL_ARM_MODE := arm<br></code></pre></td></tr></table></figure><p>或者对源文件名附加 .arm 后缀，指示构建系统仅以 arm 模式构建特定的源文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">LOCAL_SRC_FILES := foo.c bar.c.arm<br></code></pre></td></tr></table></figure><p>也可以在 Application.mk 文件中将 APP_OPTIM 设置为 debug，强制构建系统生成 ARM 二进制文件。指定 debug 会强制构建 ARM，因为工具链调试程序无法正确处理 Thumb 代码。</p><ul><li>LOCAL_ARM_NEON</li></ul><p>此变量仅在以 armeabi-v7a ABI 为目标时才有意义。它允许在 C 和 C++ 源文件中使用 ARM Advanced SIMD (NEON) 编译器固有特性，以及在 Assembly 文件中使用 NEON 指令</p><p>并非所有基于 ARMv7 的 CPU 都支持 NEON 扩展指令集。因此，必须执行运行时检测，以便在运行时安全地使用此代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">LOCAL_SRC_FILES = foo.c.neon bar.c zoo.c.arm.neon<br></code></pre></td></tr></table></figure><p>同时使用这两个后缀时，<code>.arm</code> 必须在 <code>.neon</code> 前面。</p><ul><li>LOCAL_DISABLE_FORMAT_STRING_CHECKS</li></ul><p>默认情况下，构建系统会在编译代码时保护格式字符串。这样的话，如果 <code>printf</code> 样式的函数中使用了非常量格式的字符串，就会强制引发编译器错误。</p><p>可通过将此变量的值设置为 true 将其停用，不建议停用。</p><ul><li>LOCAL_EXPORT_CFLAGS</li></ul><p>记录一组 C&#x2F;C++ 编译器标记，这些标记将被添加到使用通过 LOCAL_STATIC_LIBRARIES 或 LOCAL_SHARED_LIBRARIES 变量所描述模块的其他模块的 LOCAL_CFLAGS 定义中。</p><p>如下，foo 模块被 bar 模块依赖，那么标记 <code>-DFOO=1</code> 将在 bar 模块构建时和 <code>-DBAR=2</code> 一起传递至编译器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">include $(CLEAR_VARS)<br>LOCAL_MODULE := foo<br>LOCAL_SRC_FILES := foo/foo.c<br>LOCAL_EXPORT_CFLAGS := -DFOO=<span class="hljs-number">1</span><br>include $(BUILD_STATIC_LIBRARY)<br><br>include $(CLEAR_VARS)<br>LOCAL_MODULE := bar<br>LOCAL_SRC_FILES := bar.c<br>LOCAL_CFLAGS := -DBAR=<span class="hljs-number">2</span><br>LOCAL_STATIC_LIBRARIES := foo<br>include $(BUILD_SHARED_LIBRARY)<br></code></pre></td></tr></table></figure><p>构建系统单独编译 foo 模块时，不会将 -DFoo 标记传递至编译器。</p><p>如果有其他模块例如 zoo 依赖于 bar，那么标记将被传递。</p><ul><li>LOCAL_EXPORT_CPPFLAGS</li></ul><p>与 <code>LOCAL_EXPORT_CFLAGS</code> 相同，但仅适用于 C++ 标记。</p><ul><li>LOCAL_EXPORT_C_INCLUDES</li></ul><p>与 <code>LOCAL_EXPORT_CFLAGS</code> 相同，但适用于 C include 路径。</p><ul><li>LOCAL_EXPORT_LDFLAGS</li></ul><p>与 <code>LOCAL_EXPORT_CFLAGS</code> 相同，但适用于链接器标记。</p><ul><li>LOCAL_EXPORT_LDLIBS</li></ul><p>此变量与 <code>LOCAL_EXPORT_CFLAGS</code> 相同，用于指示构建系统将特定系统库的名称传递到编译器。请在您指定的每个库名称前附加 -l</p><p>构建系统会将导入的链接器标记附加到模块的 <code>LOCAL_LDLIBS</code> 变量值上。其原因在于 Unix 链接器的工作方式</p><p>对于静态库会很有用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">include $(CLEAR_VARS)<br>LOCAL_MODULE := foo<br>LOCAL_SRC_FILES := foo/foo.c<br>LOCAL_EXPORT_LDLIBS := -llog<br>include $(BUILD_STATIC_LIBRARY)<br><br>include $(CLEAR_VARS)<br>LOCAL_MODULE := bar<br>LOCAL_SRC_FILES := bar.c<br>LOCAL_STATIC_LIBRARIES := foo<br>include $(BUILD_SHARED_LIBRARY)<br></code></pre></td></tr></table></figure><p>那么构建系统在构建 libbar.so 时，将在链接器命令的末尾指定 -llog。告知链接器，由于 libbar.so 依赖于 foo，所以它也依赖于系统日志记录库。</p><ul><li>LOCAL_SHORT_COMMANDS</li></ul><p>当模块有很多源文件和 &#x2F; 或依赖的静态或共享库时，请将此变量设置为 <code>true</code>，这样会强制构建系统将 <code>@</code> 语法用于包含中间对象文件或链接库的归档。</p><p>此功能在 Windows 上可能很有用，在 Windows 上，命令行最多只接受 8191 个字符，这对于复杂的项目来说可能太少。它还会影响个别源文件的编译，而且将几乎所有编译器标记都放在列表文件内。</p><p>此功能会减慢构建速度。</p><ul><li>LOCAL_THIN_ARCHIVE</li></ul><p>构建静态库时，请设置为 <code>true</code>。这样会生成一个瘦归档，即一个库文件，其中不含对象文件，而只包含它通常包含的实际对象的文件路径。</p><p>在非静态库模块或预构建的静态库模块中，将会忽略此变量。</p><ul><li>LOCAL_FILTER_ASM</li></ul><p>请将此变量定义为一个 shell 命令，供构建系统用于过滤根据您为 <code>LOCAL_SRC_FILES</code> 指定的文件提取或生成的汇编文件。定义此变量会导致发生以下情况：</p><ol><li>构建系统从任何 C 或 C++ 源文件生成临时汇编文件，而不是将它们编译到对象文件中；</li><li>构建系统在任何临时汇编文件以及 <code>LOCAL_SRC_FILES</code> 中所列任何汇编文件的 <code>LOCAL_FILTER_ASM</code> 中执行 shell 命令，因此会生成另一个临时汇编文件；</li><li>构建系统将这些过滤的汇编文件编译到对象文件中。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">LOCAL_SRC_FILES  := foo.c bar.S<br>LOCAL_FILTER_ASM :=<br><br>foo.c -<span class="hljs-number">-1</span>--&gt; $OBJS_DIR/foo.S.original -<span class="hljs-number">-2</span>--&gt; $OBJS_DIR/foo.S -<span class="hljs-number">-3</span>--&gt; $OBJS_DIR/foo.o<br>bar.S<br></code></pre></td></tr></table></figure><p>“1” 对应于编译器，“2” 对应于过滤器，“3” 对应于汇编程序。过滤器必须是一个独立的 shell 命令，它接受输入文件名作为第一个参数，接受输出文件名作为第二个参数。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">myasmfilter $OBJS_DIR/foo.S.original $OBJS_DIR/foo.S<br>myasmfilter bar.S $OBJS_DIR/bar.S<br></code></pre></td></tr></table></figure><h3 id="3-5-NDK-提供的函数宏"><a href="#3-5-NDK-提供的函数宏" class="headerlink" title="3.5 NDK 提供的函数宏"></a>3.5 NDK 提供的函数宏</h3><p>NDK 提供了一些 GNU Make 的函数宏，使用 <code>$(call &lt;function&gt;)</code> 调用求值，返回相应文本信息。</p><ul><li>my-dir</li></ul><p>返回最后包括的 makefile 的路径，通常是当前 Android.mk 的目录。</p><p>由于 GNU Make 的工作方式，这个宏实际返回的是构建系统解析构建脚本时包含的最后一个 makefile 的路径。因此，包括其他文件后就不应调用 my-dir，可以提前把返回值保存起来，避免受影响。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">MY_LOCAL_PATH := $(call my-dir)<br><br>LOCAL_PATH := $(MY_LOCAL_PATH)<br><br><br><br>include $(LOCAL_PATH)/foo/`Android.mk`<br><br>LOCAL_PATH := $(MY_LOCAL_PATH)<br></code></pre></td></tr></table></figure><ul><li>all-subdir-makefiles</li></ul><p>返回位于当前 my-dir 路径所有子目录中的 Android.mk 文件列表</p><p>利用此函数，您可以为构建系统提供深度嵌套的源目录层次结构。默认情况下，NDK 只在 Android.mk 文件所在的目录中查找文件。</p><ul><li>this-makefile</li></ul><p>返回当前 makefile（构建系统从中调用函数）的路径。</p><ul><li>parent-makefile</li></ul><p>返回包含树中父 makefile 的路径（包含当前 makefile 的 makefile 的路径）。</p><ul><li>grand-parent-makefile</li></ul><p>返回包含树中祖父 makefile 的路径（包含当前父 makefile 的 makefile 的路径）。</p><ul><li>import-module</li></ul><p>此函数用于按模块名称来查找和包含模块的 Android.mk 文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">$(call <span class="hljs-keyword">import</span>-<span class="hljs-keyword">module</span>,&lt;name&gt;)<br></code></pre></td></tr></table></figure><p>构建系统在 <code>NDK_MODULE_PATH</code> 环境变量所引用的目录列表中查找具有 <code>&lt;name&gt;</code> 标记的模块，并且自动包括其 Android.mk 文件</p><h2 id="4-Application-mk-变量参考"><a href="#4-Application-mk-变量参考" class="headerlink" title="4. Application.mk 变量参考"></a>4. Application.mk 变量参考</h2><p>Application.mk 指定 NDK 工程的项目级设置。</p><p>许多参数具有模块等效项，例如，<code>APP_CFLAGS</code> 对应于 <code>LOCAL_CFLAGS</code>，基于特定模块的选项优于项目级的选项。</p><p>对于标记来说，如果两者都使用，那么特定于模块的标记将后出现在命令行中，因此它们会替换项目级设置。</p><ul><li>APP_ABI</li></ul><p>默认情况下，NDK 构建系统会为所有有效的 ABI 生成代码。可以使用 APP_ABI 设置为特定 ABI 生成代码。</p><table><thead><tr><th>Instruction set</th><th>Value</th></tr></thead><tbody><tr><td>32-bit ARMv7</td><td>APP_ABI := armeabi-v7a</td></tr><tr><td>64-bit ARMv8 (AArch64)</td><td>APP_ABI := arm64-v8a</td></tr><tr><td>x86</td><td>APP_ABI := X86</td></tr><tr><td>x86-64</td><td>APP_ABI := x86_64</td></tr><tr><td>All supported ABIs (default)</td><td>APP_ABI：= all</td></tr></tbody></table><p>可指定多个值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">APP_ABI := armeabi-v7a arm64-v8a x86<br></code></pre></td></tr></table></figure><p>Gradle 中的 <code>externalNativeBuild</code> 设置会忽略 <code>APP_ABI</code>。需要在 <code>splits</code> 块内部使用 <code>abiFilters</code> 块或 <code>abi</code> 块。</p><ul><li>APP_ASFLAGS</li></ul><p>要传递给项目中每个汇编源文件（.s 和 .S 文件）的编译器的标记。</p><p><code>ASFLAGS</code> 与 <code>ASMFLAGS</code> 不同。后者专用于 YASM 源文件。</p><p>APP_BUILD_SCRIPT</p><p>如需从其他位置加载 Android.mk 文件，将 <code>APP_BUILD_SCRIPT</code> 设置为 Android.mk 文件的绝对路径。</p><p>Gradle 中的 <code>externalNativeBuild</code> 块将根据 <code>externalNativeBuild.ndkBuild.path</code> 变量自动设置此路径。</p><ul><li>APP_CFLAGS</li></ul><p>为项目中的所有 C&#x2F;C++ 编译传递的标记。</p><ul><li>APP_CLANG_TIDY</li></ul><p>为项目中的所有模块启用 clang-tidy，将此标记设置为 <code>True</code>。默认为停用状态。</p><ul><li>APP_CLANG_TIDY_FLAGS</li></ul><p>要为项目中的所有 clang-tidy 执行传递的标记。</p><ul><li>APP_CONLYFLAGS</li></ul><p>要为项目中的所有 C 编译传递的标记。这些标记不会用于 C++ 代码。</p><ul><li>APP_CPPFLAGS</li></ul><p>要为项目中的所有 C++ 编译传递的标记。这些标记不会用于 C 代码。</p><ul><li>APP_CXXFLAGS</li></ul><p><code>APP_CPPFLAGS</code> 应优先于 <code>APP_CXXFLAGS</code>。</p><p>与 <code>APP_CPPFLAGS</code> 相同，但在编译命令中将出现在 <code>APP_CPPFLAGS</code> 之后。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">APP_CPPFLAGS := -DFOO<br>APP_CXXFLAGS := -DBAR<br></code></pre></td></tr></table></figure><p>以上配置将导致编译命令类似于 <code>clang++ -DFOO -DBAR</code>，而不是 <code>clang++ -DBAR -DFOO</code>。</p><ul><li>APP_DEBUG</li></ul><p>构建可调试的应用，将此标记设置为 <code>True</code>。</p><ul><li>APP_LDFLAGS</li></ul><p>关联可执行文件和共享库时要传递的标记。</p><p>这些标记对静态库没有影响。不会关联静态库。</p><ul><li>APP_MANIFEST</li></ul><p>AndroidManifest.xml 文件的绝对路径。</p><p>默认情况下将使用 $(APP_PROJECT_PATH)&#x2F;AndroidManifest.xml)（如果存在）。</p><p>使用 <code>externalNativeBuild</code> 时，Gradle 不会设置此值。</p><ul><li>APP_MODULES</li></ul><p>要构建的模块的显式列表。此列表的元素是模块在 Android.mk 文件的 <code>LOCAL_MODULE</code> 中显示的名称。</p><p>默认情况下，ndk-build 将构建所有共享库、可执行文件及其依赖项。仅当项目使用静态库、项目仅包含静态库或者在 <code>APP_MODULES</code> 中指定了静态库时，才会构建静态库。</p><p>不会构建导入的模块（在使用 $(call import-module) 导入的构建脚本中定义的模块），除非要在 APP_MODULES 中构建或列出的模块依赖导入的模块。</p><ul><li>APP_OPTIM</li></ul><p>定义为 <code>release</code> 或 <code>debug</code>。默认情况下，将构建 <code>relase</code> 模式的二进制文件。</p><p><code>release</code> 模式会启用优化，并可能生成无法与调试程序一起使用的二进制文件。<code>debug</code> 模式会停用优化，以便可以使用调试程序。</p><p>应用清单的 <code>&lt;application&gt;</code> 标记中声明 <code>android:debuggable</code> 将导致此变量默认为 <code>debug</code>，而不是 <code>release</code>。将 <code>APP_OPTIM</code> 设置为 <code>release</code> 可替换此默认值。</p><p>使用 externalNativeBuild 进行构建时，Android Studio 将根据您的构建风格适当地设置此标记。</p><ul><li>APP_PLATFORM</li></ul><p>声明构建此应用所面向的 Android API 级别，并对应于应用的 <code>minSdkVersion</code>。</p><p>如果未指定，ndk-build 将以 NDK 支持的最低 API 级别为目标。最新 NDK 支持的最低 API 级别总是足够低，支持几乎所有有效设备。</p><p>将 <code>APP_PLATFORM</code> 设置为高于应用的 <code>minSdkVersion</code> 可能会生成一个无法在旧设备上运行的应用。在大多数情况下，库将无法加载，因为它们引用了在旧设备上不可用的符号。</p><p>使用 Gradle 和 <code>externalNativeBuild</code> 时，不应直接设置此参数。而应在模块级别 build.gradle 文件的 <code>defaultConfig</code> 或 <code>productFlavors</code> 块中设置 <code>minSdkVersion</code> 属性。这样就能确保只有在运行足够高 Android 版本的设备上安装的应用才能使用您的库。</p><p>NDK 不包含 Android 每个 API 级别的库，省略了不包含新的原生 API 的版本以节省 NDK 中的空间。ndk-build 按以下优先级降序使用 API：</p><ol><li>匹配 <code>APP_PLATFORM</code> 的平台版本。</li><li>低于 <code>APP_PLATFORM</code> 的下一个可用 API 级别。例如，<code>APP_PLATFORM</code> 为 <code>android-20</code> 时，将使用 <code>android-19</code>，因为 <code>android-20</code> 中没有新的原生 API;</li><li>NDK 支持的最低 API 级别。</li></ol><ul><li>APP_PROJECT_PATH</li></ul><p>项目根目录的绝对路径。</p><ul><li>APP_SHORT_COMMANDS</li></ul><p><code>LOCAL_SHORT_COMMANDS</code> 的项目级等效项。</p><ul><li>APP_STL</li></ul><p>用于此应用的 C++ 标准库。</p><p>默认情况下使用 <code>system STL</code>。其他选项包括 <code>c++_shared</code>、<code>c++_static</code> 和 <code>none</code>。</p><ul><li>APP_STRIP_MODE</li></ul><p>要为此应用中的模块传递给 <code>strip</code> 的参数。默认为 <code>--strip-unneeded</code>。若要避免剥离模块中的所有二进制文件，请将其设置为 <code>none</code>。</p><ul><li>APP_THIN_ARCHIVE</li></ul><p>为项目中的所有静态库使用瘦归档，将此变量设置为 <code>True</code>。</p><ul><li>APP_WRAP_SH</li></ul><p>要包含在此应用中的 <code>wrap.sh</code> 文件的路径。</p><p>每个 ABI 都存在此变量的变体，ABI 通用变体也是如此：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">APP_WRAP_SH<br>APP_WRAP_SH_armeabi-v7a<br>APP_WRAP_SH_arm64-v8a<br>APP_WRAP_SH_x86<br>APP_WRAP_SH_x86_64<br></code></pre></td></tr></table></figure><p><code>APP_WRAP_SH_&lt;abi&gt;</code> 可能无法与 <code>APP_WRAP_SH</code> 结合使用。如果有任何 ABI 使用特定于 ABI 的 <code>wrap.sh</code>，所有 ABI 都必须使用该 <code>wrap.sh</code>。</p><h2 id="5-NDK-API"><a href="#5-NDK-API" class="headerlink" title="5. NDK API"></a>5. NDK API</h2><p>NDK 开发几乎必须要使用到 NDK 提供的原生 API，最常用的就是 <code>liblog</code>，用来在 logcat 中打印日志，下面分别使用 Android.mk 和 CMake 引入日志库。</p><p>引入其他库方法一致，可用 NDK 库列表可参考官方文档：<a href="https://developer.android.google.cn/ndk/guides/stable_apis">https://developer.android.google.cn/ndk/guides/stable_apis</a></p><h3 id="5-1-Android-mk"><a href="#5-1-Android-mk" class="headerlink" title="5.1 Android.mk"></a>5.1 Android.mk</h3><p>非常简单，只需要在 Android.mk 文件中使用 <code>LOCAL_LDLIBS</code> 变量使用 <code>-l</code> 前缀描述需要连接的库即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp">LOCAL_PATH := $(call my-dir)<br><br>$(warning $(TARGET_PLATFORM))<br><br>include $(CLEAR_VARS)<br><br>LOCAL_MODULE := foo<br>LOCAL_SRC_FILES := libfoo.cpp<br><br><br>LOCAL_LDLIBS := -llog<br><br>include $(BUILD_SHARED_LIBRARY)<br></code></pre></td></tr></table></figure><p>此时在源代码中即可使用 <code>android/log.h</code> 引入日志打印方法了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;android/log.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;main.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;android/log.h&gt;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *TAG = <span class="hljs-string">&quot;NDK&quot;</span>;<br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><br><span class="hljs-function">jstring <span class="hljs-title">Java_io_l0neman_mkexample_NativeHandler_getHello</span><span class="hljs-params">(JNIEnv *env, jclass clazz)</span> </span>&#123;<br>  __android_log_print(ANDROID_LOG_DEBUG, TAG, <span class="hljs-string">&quot;log test.&quot;</span>);<br>  <span class="hljs-keyword">return</span> env-&gt;<span class="hljs-built_in">NewStringUTF</span>(<span class="hljs-string">&quot;Hello-jni&quot;</span>);<br>&#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="5-2-CMake"><a href="#5-2-CMake" class="headerlink" title="5.2 CMake"></a>5.2 CMake</h3><p>CMake 描述如下，首先使用 <code>find_library</code> 描述 NDK 库，再用 <code>target_link_libraries</code> 指定链接库：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.4</span><span class="hljs-number">.3</span>)<br><br><span class="hljs-built_in">add_library</span>(<br>        foo<br>        SHARED<br>        main.cpp<br>)<br><br><span class="hljs-built_in">find_library</span>(<br>        <br>        log-lib<br>        <br>        log<br>)<br><br><br><span class="hljs-built_in">target_link_libraries</span>(<br>        foo<br>        $&#123;log-lib&#125;<br>)<br></code></pre></td></tr></table></figure><p>如果需要添加多个库，新增 <code>find_library</code> 块，添加另一个库的描述后，在 <code>target_link_libraries</code> 加入即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">...<br><br><span class="hljs-built_in">find_library</span>(<br>        zip-lib<br>        z<br>)<br><br><span class="hljs-built_in">target_link_libraries</span>(<br>        foo<br>        $&#123;log-lib&#125;<br>        $&#123;zip-lib&#125;<br>)<br></code></pre></td></tr></table></figure><h2 id="6-引入预编译库"><a href="#6-引入预编译库" class="headerlink" title="6. 引入预编译库"></a>6. 引入预编译库</h2><p>有时需要引入提前编译好或者第三方提供的 so 共享库，或是引入现成的 .a 静态库，那么根据情况进行如下配置。</p><h3 id="6-1-引入动态库"><a href="#6-1-引入动态库" class="headerlink" title="6.1 引入动态库"></a>6.1 引入动态库</h3><ol><li>首先在独立的 NDK 工程编译出一个共享库 libbar.so（创建 libbar Module），作为第三方库提供给其他 Module 使用。</li></ol><p>工程目录结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">jni<br> |<br> +-- Android.mk<br> +-- Application.mk<br> +-- libbar.h<br> +-- libbar.cpp<br></code></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> NDKTPROJECT_LIBBAR_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NDKTPROJECT_LIBBAR_H</span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bar_add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;<br><br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;libbar.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bar_add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">LOCAL_PATH := $(call my-dir)<br><br>include $(CLEAR_VARS)<br><br>LOCAL_MODULE := bar<br>LOCAL_SRC_FILES := libbar.cpp<br><br>include $(BUILD_SHARED_LIBRARY)<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">APP_ABI := armeabi-v7a arm64-v8a x86 x86_64<br>APP_OPTIM := debug<br></code></pre></td></tr></table></figure><p>使用命令行进入 jni 目录下，然后执行 ndk-build 编译出 4 种架构的 libbar.so 文件，在和 jni 同级的 libs 目录下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp">jni<br>libs<br> |<br> +-- armeabi-v7a<br> |    +-- libbar.so<br> |<br> +-- arm64-v8a<br> |    +-- libbar.so<br> |<br> +-- x86<br> |    +-- libbar.so<br> |<br> +-- x86_64<br>      +-- libbar.so<br></code></pre></td></tr></table></figure><ol start="2"><li>将每种架构目录复制到需要使用此库的 NDK 工程中（libfoo.so Module），在工程中新建 include 目录，将 libbar 的头文件复制过来，为了提供调用的接口。</li></ol><p>工程目录结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp">jni<br> |<br> +-- armeabi-v7a<br> |    +-- libbar.so<br> |<br> +-- arm64-v8a<br> |    +-- libbar.so<br> |<br> +-- x86<br> |    +-- libbar.so<br> |<br> +-- x86_64<br> |    +-- libbar.so<br> |<br> +-- include<br> |    +-- libbar.h<br> |<br> +-- Android.mk<br> +-- Application.mk<br> +-- libfoo.h<br> +-- libfoo.cpp<br></code></pre></td></tr></table></figure><ol start="3"><li>编写 libfoo.so Module 的 Android.mk 文件，<code>$(TARGET_ARCH_ABI)</code> 为 NDK 编译时每种架构的名字。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp">LOCAL_PATH := $(call my-dir)<br><br>include $(CLEAR_VARS)<br><br>LOCAL_MODULE := libbar-pre<br><br>LOCAL_SRC_FILES := $(TARGET_ARCH_ABI)/libbar.so<br><br>LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH)/include<br>include $(PREBUILT_SHARED_LIBRARY)<br><br>include $(CLEAR_VARS)<br>LOCAL_MODULE := foo<br>LOCAL_SRC_FILES := main.cpp<br><br>LOCAL_SHARED_LIBRARIES := libbar-pre<br>include $(BUILD_SHARED_LIBRARY)<br></code></pre></td></tr></table></figure><p>此时当工程编译时，对应的 libbar.so 将会自动被加入到 apk 包中。</p><ol start="4"><li>代码调用</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> NDKTPROJECT_LIBFOO_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NDKTPROJECT_LIBFOO_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;jni.h&gt;</span></span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><br><span class="hljs-function">JNIEXPORT <span class="hljs-type">void</span> JNICALL</span><br><span class="hljs-function"><span class="hljs-title">Java_io_l0neman_mkexample_NativeHandler_test</span><span class="hljs-params">(JNIEnv *env, jclass clazz)</span></span>;<br><br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;libbar.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;libfoo.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Java_io_l0neman_mkexample_NativeHandler_test</span><span class="hljs-params">(JNIEnv *env, jclass clazz)</span> </span>&#123;<br>  <span class="hljs-type">int</span> a = <span class="hljs-built_in">bar_add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, a);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>Java 层调用测试</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NativeHandler</span> &#123;<br><br>  <span class="hljs-type">static</span> &#123;<br>    <br>    System.<span class="hljs-built_in">loadLibrary</span>(<span class="hljs-string">&quot;foo&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> native <span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">NativeHandler.<span class="hljs-built_in">test</span>();<br></code></pre></td></tr></table></figure><h3 id="6-2-引入静态库"><a href="#6-2-引入静态库" class="headerlink" title="6.2 引入静态库"></a>6.2 引入静态库</h3><ol><li>首先编译出 .a 后缀的静态库 libbar.a。</li></ol><p>工程结构和上面引入动态库中的 libbar 工程一致，只需要将 Android.mk 文件中引入的 <code>BUILD_SHARED_LIBRARY</code> 变量修改为 <code>BUILD_STATIC_LIBRARY</code> 即可指定编译出静态库。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">LOCAL_PATH := $(call my-dir)<br><br>include $(CLEAR_VARS)<br><br>LOCAL_MODULE := bar<br>LOCAL_SRC_FILES := libbar.cpp<br><br><br>include $(BUILD_STATIC_LIBRARY)<br></code></pre></td></tr></table></figure><p>使用 ndk-build 编译后，不会产生和 jni 同级的 libs 目录，每种架构的 libbar.a 文件将出现在和 jni 同级的 obj 目录中。</p><p>目录结构如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp">jni<br>obj<br> |<br> +-- armeabi-v7a<br> |    +-- libbar.a<br> |<br> +-- arm64-v8a<br> |    +-- libbar.a<br> |<br> +-- x86<br> |    +-- libbar.a<br> |<br> +-- x86_64<br>      +-- libbar.a<br></code></pre></td></tr></table></figure><ol start="2"><li>在 libfoo.so 工程中引入静态库，步骤和引入动态库大同小异，把 obj 中每种架构的目录复制到需要使用此库的 NDK 工程中（libfoo.so），在工程中新建 include 目录，将 libbar 的头文件复制过来，为了提供调用的接口。</li></ol><p>工程目录结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp">jni<br> |<br> +-- armeabi-v7a<br> |    +-- libbar.a<br> |<br> +-- arm64-v8a<br> |    +-- libbar.a<br> |<br> +-- x86<br> |    +-- libbar.a<br> |<br> +-- x86_64<br> |    +-- libbar.a<br> |<br> +-- include<br> |   +-- libbar.h<br> |<br> +-- Android.mk<br> +-- Application.mk<br> +-- libfoo.h<br> +-- libfoo.cpp<br></code></pre></td></tr></table></figure><ol start="3"><li>编写 libfoo.so 的 Android.mk 文件，<code>$(TARGET_ARCH_ABI)</code> 为 NDK 编译时每种架构的名字。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp">LOCAL_PATH := $(call my-dir)<br><br>include $(CLEAR_VARS)<br><br>LOCAL_MODULE := libbar-pre<br><br>LOCAL_SRC_FILES := $(TARGET_ARCH_ABI)/libbar.a<br><br>LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH)/include<br>include $(PREBUILT_STATIC_LIBRARY)<br><br>include $(CLEAR_VARS)<br>LOCAL_MODULE := foo<br>LOCAL_SRC_FILES := main.cpp<br><br>LOCAL_STATIC_LIBRARIES := libbar-pre<br>include $(BUILD_SHARED_LIBRARY)<br></code></pre></td></tr></table></figure><p>此时当工程编译时，对应的 libbar.a 将会自动编译到 libfoo.so 中，成为它的一部分。</p><ol start="4"><li>最后引用头文件正常调用编译即可，参考引用动态库中的步骤 4。</li></ol><h3 id="6-3-CMake"><a href="#6-3-CMake" class="headerlink" title="6.3 CMake"></a>6.3 CMake</h3><p>上面的两个示例均为 Android.mk 构建示例，使用 CMake 构建简要描述如下：</p><ul><li>引入动态库</li></ul><p>首先将前面 libbar.so 复制到 CMake 项目的 jniLibs 中，项目结构如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp">main<br> |<br> +-- cpp<br> |    |<br> |    +-- include<br> |    |    |<br> |    |    +-- libbar.h<br> |    |<br> |    +-- libfoo.cpp<br> |    +-- libfoo.h<br> |    +-- CMakeLists.txt<br> |<br> +-- jniLibs<br>      |<br>      +-- armeabi-v7a<br>      |    +-- libbar.so<br>      |<br>      +-- arm64-v8a<br>      |    +-- libbar.so<br>      |<br>      +-- x86<br>      |    +-- libbar.so<br>      |<br>      +-- x86_64<br>           +-- libbar.so<br></code></pre></td></tr></table></figure><p>将预编译库放在 jniLibs 下面是为了在编译时打包到 apk 中。</p><p>其中 libfoo.cpp 和 libfoo.h 与上述 Android.mk 中源码一致，重点关注 CMakeLists.txt：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.4</span><span class="hljs-number">.3</span>)<br><br><span class="hljs-built_in">set</span>(CURRENT_DIR $&#123;CMAKE_SOURCE_DIR&#125;)<br><br><span class="hljs-built_in">add_library</span>(<br>        foo<br>        SHARED<br>        main.cpp<br>)<br><br><span class="hljs-built_in">add_library</span>(<br>        bar-lib<br>        SHARED<br>        IMPORTED<br>)<br><br><span class="hljs-built_in">set_target_properties</span>(<br>        bar-lib<br>        PROPERTIES IMPORTED_LOCATION<br>        $&#123;CMAKE_SOURCE_DIR&#125;/../jniLibs/$&#123;ANDROID_ABI&#125;/libbar.so<br>)<br><br><span class="hljs-built_in">include_directories</span>(include/)<br><br><span class="hljs-built_in">target_link_libraries</span>(<br>        foo<br>        bar-lib<br>)<br></code></pre></td></tr></table></figure><p>编译测试即可。</p><ul><li>引入静态库</li></ul><p>将前面 libbar.a 复制到 CMake 项目的 cpp 中，项目结构如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cpp<br> |<br> +-- include<br> |    |<br> |    +-- libbar.h<br> |<br> +-- libfoo.cpp<br> +-- libfoo.h<br> +-- CMakeLists.txt<br> |<br> +-- armeabi-v7a<br> |    +-- libbar.a<br> |<br> +-- arm64-v8a<br> |    +-- libbar.a<br> |<br> +-- x86<br> |    +-- libbar.a<br> |<br> +-- x86_64<br>      +-- libbar.a<br></code></pre></td></tr></table></figure><p>由于静态库 .a 直接编译到目标文件 libfoo 中，所以不用放在 jniLibs 打包至 apk 中。</p><p>CMakeLists.txt：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.4</span><span class="hljs-number">.3</span>)<br><br><span class="hljs-built_in">set</span>(CURRENT_DIR $&#123;CMAKE_SOURCE_DIR&#125;)<br><br><span class="hljs-built_in">add_library</span>(<br>        foo<br>        SHARED<br>        main.cpp<br>)<br><br><span class="hljs-built_in">add_library</span>(<br>        bar-lib<br>        STATIC<br>        IMPORTED<br>)<br><br><span class="hljs-built_in">set_target_properties</span>(<br>        bar-lib<br>        PROPERTIES IMPORTED_LOCATION<br>        $&#123;CMAKE_SOURCE_DIR&#125;/$&#123;ANDROID_ABI&#125;/libbar.a<br>)<br><br><span class="hljs-built_in">include_directories</span>(include/)<br><br><span class="hljs-built_in">target_link_libraries</span>(<br>        foo<br>        bar-lib<br>)<br></code></pre></td></tr></table></figure><p>编译测试即可。</p><h2 id="7-参考"><a href="#7-参考" class="headerlink" title="7. 参考"></a>7. 参考</h2><p>参考： <a href="https://developer.android.google.cn/ndk/guides/build">https://developer.android.google.cn/ndk/guides/build</a></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JNI</tag>
      
      <tag>NDK</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android JNI指南</title>
    <link href="/2025/01/15/Android-JNI%E6%8C%87%E5%8D%97/"/>
    <url>/2025/01/15/Android-JNI%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<blockquote><p>发现的写比较好的博客文章，备份到本地， 原文地址 <a href="https://l0neman.github.io/2020/07/14/android-jni-%E6%8C%87%E5%8D%97/#JNI-%E6%96%B9%E6%B3%95%E6%B3%A8%E5%86%8C">l0neman.github.io</a></p></blockquote><blockquote><p>前言编写此文档的用意： 作为 Android NDK 项目开发的参考手册。</p></blockquote><h2 id="1-千年"><a href="#1-千年" class="headerlink" title="1. 千年"></a>1. 千年</h2><p>编写此文档的用意：</p><p>作为 Android NDK 项目开发的参考手册。</p><p>对于 NDK 工程的搭建可参考 <a href="https://l0neman.github.io/2020/07/14/android-ndk-%E6%8C%87%E5%8D%97/">Android NDK 指南</a></p><h2 id="2-JNI简介"><a href="#2-JNI简介" class="headerlink" title="2. JNI简介"></a>2. JNI简介</h2><p>JNI（Java Native Interface，Java 原生接口），是 Java 和 C++ 组件用以互相通信的接口。</p><p>Android 平台下的 JNI 支持由 Android NDK 提供，它是一套能将 C 或 C++（原生代码）嵌入到 Android 应用中的工具。</p><h2 id="3-JNI优化原则"><a href="#3-JNI优化原则" class="headerlink" title="3. JNI优化原则"></a>3. JNI优化原则</h2><p>为什么要使用 JNI 在 Android 平台下进行编程：</p><ol><li><p>在平台之间移植应用；</p></li><li><p>重复使用现有库，或者提供自己的库供重复使用；</p></li><li><p>在某些情况下提供高性能，特别是像游戏这种计算密集型应用；</p></li><li><p>提供安全性保障，在二进制层面比字节码层面的逆向工作更加困难。</p></li><li><p>尽可能减少跨 JNI 层的编组（Marshalling）数据资源的次数，因为跨 JNI 层进行编组的开销很大。尽可能设计一种接口，减少需要编组的数据量以及必须进行数据编组的频率；</p></li><li><p>尽量避免在使用受管理的编程语言（在虚拟机中运行）中与 C&#x2F;C++ 编写的代码之间进行异步通信（例如 C&#x2F;C++ 中开启线程后直接回调 Java 语言），这样可以使 JNI 接口更容易维护。通常使用与编写界面的相同语言进行异步更新，以简化异步界面的更新，例如，使用 Java 语言创建线程，然后发出对 C++ 层的阻塞调用，然后在阻塞完成后通知界面线程；</p></li><li><p>尽可能减少需要访问 JNI 或被 JNI 访问的线程数。如果确实需要以 Java 和 C++ 两种语言来利用线程池，请尝试在池所有者之间（而不是各个工作线程之间）保持 JNI 通信；</p></li><li><p>将接口保存在少量的容易识别的 C++ 和 Java 源位置，以便于将来进行重构。</p></li></ol><h2 id="4-名词说明"><a href="#4-名词说明" class="headerlink" title="4. 名词说明"></a>4. 名词说明</h2><p>下文叙述中使用到的名词说明：</p><ul><li><p>JNI 方法，在 Java 层使用 native 声明，使用 C&#x2F;C++ 中实现的方法。</p></li><li><p>JNI 函数，JNI 提供的与 Java 层交互的工具一系列函数，例如 <code>RegisterNatives</code>。</p></li><li><p>不透明，具体结构未知，由具体的虚拟机实现决定。</p></li></ul><h2 id="5-JavaVM-和JNIEnv"><a href="#5-JavaVM-和JNIEnv" class="headerlink" title="5. JavaVM 和JNIEnv"></a>5. JavaVM 和JNIEnv</h2><p>JNI 定义了两个关键的数据结构，<code>JavaVM</code> 和 <code>JNIEnv</code>，它们的本质都是指向函数表的二级指针（在 C++ 版本中，两者都是类，类中都有一个指向函数表的指针，它们的成员函数封装了通过函数表进行访问的 JNI 函数），可以使用 <code>JavaVM</code> 类进行创建和销毁 JavaVM 的操作。理论上，每个进程可以有多个 JavaVM，但 Android 只允许有一个。</p><p><code>JNIEnv</code> 的指针将在每个 JNI 函数的第一个参数中。</p><p>这个 <code>JNIEnv</code> 只能用于线程本地存储（Thread Local），所以无法在线程之间共享 <code>JNIEnv</code>，如果需要在其他线程中访问 <code>JNIEnv</code>，可以通过 <code>JavaVM</code> 调用 <code>GetEnv</code> 函数获得相应的 <code>JNIEnv</code> 指针（需要在之前使用过 <code>AttachCurrentThread</code> 对此线程进行附加后调用）。</p><p><code>JavaVM</code> 指针是全局的，可以在线程之间共享，通过保存 <code>JavaVM</code> 用于在其他线程中获取 <code>JNIEnv</code>。</p><p><code>JNIEnv</code> 和 <code>JavaVM</code> 在 C 源文件和 C++ 源文件中的声明不同，使用 C 文件和 C++ 文件包含 <code>jni.h</code> 时，会有不同的类型定义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(__cplusplus)</span><br><span class="hljs-keyword">typedef</span> _JNIEnv JNIEnv;<br><span class="hljs-keyword">typedef</span> _JavaVM JavaVM;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">JNINativeInterface</span>* JNIEnv;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">JNIInvokeInterface</span>* JavaVM;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>因此，不建议同时在这两种语言包含的头文件中添加 <code>JNIEnv</code> 参数（容易导致混乱）。或者当源文件中出现 <code>#ifdef __cplusplus</code> ，且该文件中所有的内容都引用了 <code>JNIEnv</code> 时，那么可能需要做额外的处理。</p><p>JNI 方法是 Java 代码与 C&#x2F;C++ 代码沟通的桥梁，使用它时必须首先注册。JNI 方法的声明在 Java 类中，实现在 C&#x2F;C++ 代码中，在 Java 层的方法声明前面必须添加 <code>native</code> 关键字，然后才能进行注册。</p><p>注册方式分为静态注册（根据 JNI 命令规范直接定义对应名字的 C&#x2F;C++ 函数）和动态注册（使用 <code>RegisterNatives</code> 函数注册到 C&#x2F;C++ 函数上）两种方式。</p><p>例如，Java 声明了如下 JNI 方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NativeHandler</span> &#123;<br><br>  <span class="hljs-type">static</span> &#123;<br>    System.<span class="hljs-built_in">loadLibrary</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>  &#125;<br><br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> native String <span class="hljs-title">getString</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>NDK 工程描述如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">src/main/<br> |<br> +-- java<br> +-- jni<br>      |<br>      +-- Android.mk<br>      +-- Application.mk<br>      +-- hello.cpp<br>      +-- hello.h<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">LOCAL_PATH := $(call my-dir)<br><br>include $(CLEAR_VARS)<br><br>LOCAL_MODULE    := hello<br>LOCAL_SRC_FILES := hello.cpp<br><br>include $(BUILD_SHARED_LIBRARY)<br></code></pre></td></tr></table></figure><p>下面将针对上面搭建的 NDK 工程，采用两种方式在 C&#x2F;C++ 代码中实现 Java 类 <code>NativeHandler</code> 中的 <code>getString</code> 方法并注册。</p><h2 id="6-JNI方法注册"><a href="#6-JNI方法注册" class="headerlink" title="6. JNI方法注册"></a>6. JNI方法注册</h2><h3 id="6-1-静态注册"><a href="#6-1-静态注册" class="headerlink" title="6.1  静态注册"></a>6.1  静态注册</h3><p>静态注册只需要按照 JNI 接口规范，在 C&#x2F;C++ 代码中声明一个 <code>Java_[全类名中 的 . 替换为 _]_[方法名]</code> 函数，然后添加 <code>JNIEXPORT</code> 前缀即可。</p><p>当系统加载 so 文件后，将根据名字对应规则，自动注册 JNI 方法。</p><p>下面采用了 C++ 代码描述，其中的函数需要使用 <code>extern &quot;C&quot;</code> 来包括（为了兼容 C 语言的符号签名规则，让 C 语言能够正常链接调用它）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> NDKTPROJECT_MAIN_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NDKTPROJECT_MAIN_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;jni.h&gt;</span></span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><span class="hljs-function">JNIEXPORT jstring JNICALL</span><br><span class="hljs-function"><span class="hljs-title">Java_io_l0neman_jniexample_NativeHandler_getString</span><span class="hljs-params">(JNIEnv *env, jclass clazz)</span></span>;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;main.h&quot;</span></span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><span class="hljs-function">jstring <span class="hljs-title">Java_io_l0neman_jniexample_NativeHandler_getString</span><span class="hljs-params">(JNIEnv *env, jclass clazz)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> env-&gt;<span class="hljs-built_in">NewStringUTF</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果是 C 语言代码的实现，那么可以去除 <code>extern &quot;C&quot;</code> 的声明，且返回字符串的代码要改为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">return</span> (*env)-&gt;<span class="hljs-built_in">NewStringUTF</span>(env, <span class="hljs-string">&quot;hello&quot;</span>);<br></code></pre></td></tr></table></figure><p>此时就注册完成了，Java 层可以直接调用 <code>textView.setText(NativeHandler.getString())</code> 进行测试了。</p><p>这种注册方式简单直接，但是所有 C&#x2F;C++ 中实现的 JNI 函数符号都需要被导出，对于逆向人员来说，使用 IDA Pro 可以直接看到注册 JNI 方法的名字，快速定位到对应的 Java 代码。</p><h3 id="6-2-动态注册"><a href="#6-2-动态注册" class="headerlink" title="6.2. 动态注册"></a>6.2. 动态注册</h3><p>动态注册与静态注册不同，它是用 <code>JNIEnv</code> 类型提供的 <code>registerNatives</code> 方法来将 JNI 方法动态绑定到指定的 C&#x2F;C++ 函数上。</p><p>首先需要实现 JNI 提供的标准入口函数，<code>JNI_OnLoad</code>，它将会在调用 <code>System.loadLibrary(&quot;hello&quot;)</code> 后，由 Java 虚拟机进行回调，同时可以实现可选的 <code>JNI_OnUnload</code> 函数，用于虚拟机将动态库卸载时回收资源。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">JNIEXPORT jint <span class="hljs-title">JNI_OnLoad</span><span class="hljs-params">(JavaVM *vm, <span class="hljs-type">void</span> *reserved)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> JNI_VERSION_1_6;<br>&#125;<br></code></pre></td></tr></table></figure><p>返回值表示要使用的 JNI 版本，返回低版本，将不能使用高版本提供的一些 JNI 函数，这里返回当前最高版本 <code>JNI_VERSION_1_6</code>，如果返回其它非版本数值，将导致加载 so 库失败。</p><p>完整注册代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *CLASS_NAME = <span class="hljs-string">&quot;io/l0neman/jniexample/NativeHandler&quot;</span>;<br><br><span class="hljs-function"><span class="hljs-type">static</span> jstring <span class="hljs-title">getString</span><span class="hljs-params">(JNIEnv *env, jclass nativeHandler)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> env-&gt;<span class="hljs-built_in">NewStringUTF</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>&#125;<br><br><span class="hljs-type">static</span> JNINativeMethod gMethods[] = &#123;<br>    &#123;<span class="hljs-string">&quot;getString&quot;</span>, <span class="hljs-string">&quot;()Ljava/lang/String;&quot;</span>, (<span class="hljs-type">void</span> *) getString&#125;,<br>&#125;;<br><br><span class="hljs-function">JNIEXPORT jint <span class="hljs-title">JNI_OnLoad</span><span class="hljs-params">(JavaVM *vm, <span class="hljs-type">void</span> *reserved)</span> </span>&#123;<br>  JNIEnv *env = <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-keyword">if</span> (vm-&gt;<span class="hljs-built_in">GetEnv</span>((<span class="hljs-type">void</span> **) &amp;env, JNI_VERSION_1_6) != JNI_OK) &#123;<br>    <span class="hljs-keyword">return</span> JNI_ERR;<br>  &#125;<br><br>  jclass nativeHandlerClass = env-&gt;<span class="hljs-built_in">FindClass</span>(CLASS_NAME);<br>  <span class="hljs-keyword">if</span> (nativeHandlerClass == <span class="hljs-literal">nullptr</span>) &#123;<br>    <span class="hljs-keyword">return</span> JNI_ERR;<br>  &#125;<br><br>  jint methods = <span class="hljs-built_in">sizeof</span>(gMethods) / <span class="hljs-built_in">sizeof</span>(JNINativeMethod);<br>  jint ret = env-&gt;<span class="hljs-built_in">RegisterNatives</span>(nativeHandlerClass, gMethods, methods);<br>  <span class="hljs-keyword">if</span> (ret != JNI_OK) &#123;<br>    <span class="hljs-keyword">return</span> ret;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> JNI_VERSION_1_6;<br>&#125;<br><br><span class="hljs-function">JNIEXPORT <span class="hljs-type">void</span> <span class="hljs-title">JNI_OnUnload</span><span class="hljs-params">(JavaVM *vm, <span class="hljs-type">void</span> *reserved)</span> </span>&#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>从 <code>JNI_OnLoad</code> 开始看。</p><ol><li>首先 <code>RegisterNatives</code> 这个函数由 <code>JNIEnv</code> 类型提供，而 <code>JNI_OnLoad</code> 第一个参数是 <code>JavaVM *</code>，所以，这里首先获取 <code>JNIEnv</code> 类型指针，使用 <code>JavaVM</code> 的 <code>GetEnv</code> 函数获取（由于系统默认已经附加到线程，所以这里才能直接 <code>GetEnv</code>）;</li><li>下面需要使用 <code>RegisterNatives</code> 注册 JNI 函数，看一下它的声明：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">jint <span class="hljs-title">RegisterNatives</span><span class="hljs-params">(jclass clazz, <span class="hljs-type">const</span> JNINativeMethod* methods, jint nMethods)</span></span>;<br></code></pre></td></tr></table></figure><p>第 1 个参数是 JNI 方法所在的 Java 类，第 2 个是包含需要注册的 JNI 方法对应关系的数组，第 3 个是要注册的 JNI 方法数量或者说前面的数组大小。</p><p>那么，就根据要求填充相关参数。</p><ol start="3"><li>使用 <code>JNIEnv</code> 的 <code>FindClass</code> 来获得表示 <code>NativeHandler</code> 类型的 <code>jclass</code>，可以看到描述全类名的方法，将 <code>.</code> 替换为路径符号 <code>/</code> 即可，这样得到了第一个参数；</li><li>定义一个 <code>JNINativeMethod</code> 的数组，每个 <code>JNINativeMethod</code> 都用于描述一个 JNI 方法的 Java 方法声明和 C&#x2F;C++ 函数的一对一关系。</li></ol><p><code>JNINativeMethod</code> 定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* name;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* signature;<br>    <span class="hljs-type">void</span>*       fnPtr;<br>&#125; JNINativeMethod;<br></code></pre></td></tr></table></figure><p>分别是 Java 层 JNI 方法的名字，方法签名，和要注册的 C&#x2F;C++ 函数地址。</p><p>在方法签名中，每种 Java 基本类型都有对应的签名字符串，引用类型则为 <code>L[全类型名中的 . 替换为 /];</code>。</p><p>JNI 类型签名如下表：</p><table><thead><tr><th>签名</th><th>Java 类型</th></tr></thead><tbody><tr><td>Z</td><td>boolean</td></tr><tr><td>B</td><td>byte</td></tr><tr><td>C</td><td>char</td></tr><tr><td>S</td><td>short</td></tr><tr><td>I</td><td>int</td></tr><tr><td>J</td><td>long</td></tr><tr><td>F</td><td>float</td></tr><tr><td>D</td><td>double</td></tr><tr><td>L</td><td>引用类型</td></tr><tr><td>[</td><td>数组前缀</td></tr></tbody></table><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">f</span> <span class="hljs-params">(<span class="hljs-type">int</span> n, String s, <span class="hljs-type">int</span>[] arr)</span></span>;<br></code></pre></td></tr></table></figure><p>签名为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(ILjava/lang/String;[I)J<br></code></pre></td></tr></table></figure><p>那么前面的代码中的 <code>gMethods</code> 数组，即表明了要把 <code>NativeHandler</code> 中的 <code>getString</code> 注册绑定到 C++ 中的 <code>getString</code> 函数上。</p><ol start="5"><li>最后调用 <code>env-&gt;RegisterNatives</code> 函数就可以了，一般情况下，注册成功，那么返回 <code>JNI_OK</code>。</li></ol><p>可以允许在 <code>JNI_OnLoad</code> 中绑定多个 Java 类中的 native 方法，建议不要这样做，会导致难以维护。</p><p>动态注册的好处是，可以只导出 <code>JNI_OnLoad</code>（注册的 C&#x2F;C++ 函数可以进行符号优化，不导出），生成速度更快且更小的代码，且可避免与加载到应用中的其他库发生潜在冲突。</p><h3 id="6-3-类静态方法和类成员方法"><a href="#6-3-类静态方法和类成员方法" class="headerlink" title="6.3 类静态方法和类成员方法"></a>6.3 类静态方法和类成员方法</h3><p>注册 Java 中的静态 JNI 方法和类成员 JNI 方法的区别是，对应的 C&#x2F;C++ 函数的回调参数不同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NativeHandler</span> &#123;<br><br>  <span class="hljs-type">static</span> &#123;<br>    System.<span class="hljs-built_in">loadLibrary</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> native String <span class="hljs-title">getString</span><span class="hljs-params">()</span></span>;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> native String <span class="hljs-title">getHello</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对应的 C++ 函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">jstring <span class="hljs-title">getString</span><span class="hljs-params">(JNIEnv *env, jclass nativeHandler)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> env-&gt;<span class="hljs-built_in">NewStringUTF</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>&#125;<br><br><span class="hljs-function">jstring <span class="hljs-title">getHello</span><span class="hljs-params">(JNIEnv *env, jobject thiz)</span> </span>&#123;<br>  jclass nativeHandlerClass = env-&gt;<span class="hljs-built_in">GetObjectClass</span>(thiz);<br>  <span class="hljs-keyword">return</span> env-&gt;<span class="hljs-built_in">NewStringUTF</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>静态方法传递的是代码 Java 类的 <code>jclass</code>，而类方法传递的是表示 Java <code>this</code> 对象的 <code>jobject</code>，可以使用它来访问对应的 <code>this</code> 对象内的成员变量和相关方法。如果需要访问 <code>jclass</code>，使用 JNI 提供的 <code>GetObjectClass</code> 函数获取。</p><p>在注册工作完成后，就可以从 Java 层调用 JNI 方法，使用 C&#x2F;C++ 语言处理逻辑了。</p><h2 id="7-Java层访问"><a href="#7-Java层访问" class="headerlink" title="7.Java层访问"></a>7.Java层访问</h2><p>在 C&#x2F;C++ 代码中，需要对 Java 层进行访问，最基本的两种访问操作就是读写 Java 类成员和调用 Java 类方法。</p><h3 id="7-1-Java-成员变量访问"><a href="#7-1-Java-成员变量访问" class="headerlink" title="7.1 Java 成员变量访问"></a>7.1 Java 成员变量访问</h3><p>JNI 提供了一系列访问 Java 类的静态成员和对象成员的函数，例如。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">GetStaticIntField</span>();     <br><span class="hljs-built_in">SetStaticIntField</span>();     <br><span class="hljs-built_in">GetStaticObjectField</span>();  <br><span class="hljs-built_in">SetStaticObjectField</span>();  <br><br><span class="hljs-built_in">GetIntField</span>();           <br><span class="hljs-built_in">SetIntField</span>();           <br><span class="hljs-built_in">GetObjectField</span>();        <br><span class="hljs-built_in">SetObjectField</span>();<br></code></pre></td></tr></table></figure><p>总结为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">GetStatic&lt;type&gt;<span class="hljs-built_in">Field</span>();    <br>SetStatic&lt;type&gt;<span class="hljs-built_in">Field</span>();    <br>Get&lt;type&gt;<span class="hljs-built_in">Field</span>();          <br>Set&lt;type&gt;<span class="hljs-built_in">Field</span>();<br></code></pre></td></tr></table></figure><p>当需要访问静态成员时需要提供一个代表 Java 类型的 <code>jclass</code> 作为参数，访问类对象成员时则需要一个表示 Java 对象的 <code>jobject</code> 作为参数。</p><p>同时两者都需要首先提供目标 Java 类成员的 JNI 类型签名（符合上面的 JNI 签名表规则），用来获取一个不透明的 <code>jfieldID</code> 类型，传递给 JNI 函数，用于找到目标成员，之后才能使用上述 JNI 函数访问 Java 类成员。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">jfieldID <span class="hljs-title">GetStaticFieldID</span><span class="hljs-params">(jclass clazz, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* sig)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="7-2-Java-类方法访问"><a href="#7-2-Java-类方法访问" class="headerlink" title="7.2 Java 类方法访问"></a>7.2 Java 类方法访问</h3><p>JNI 同时也提供了一系列调用 Java 类的静态方法和对象方法的函数，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">CallStaticVoidMethod</span>(); <br><span class="hljs-built_in">CallStaticIntMethod</span>();  <br><span class="hljs-built_in">CallObjectMethod</span>();     <br><br><br><span class="hljs-built_in">CallVoidMethod</span>();       <br><span class="hljs-built_in">CallIntMethod</span>();        <br><span class="hljs-built_in">CallObjectMethod</span>();<br></code></pre></td></tr></table></figure><p>总结为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">env-&gt;CallStatic&lt;type&gt;<span class="hljs-built_in">Method</span>(); <br>env-&gt;Call&lt;type&gt;<span class="hljs-built_in">Method</span>();<br></code></pre></td></tr></table></figure><p>当需要调用静态方法时需要提供一个代表 Java 类型的 <code>jclass</code> 作为参数，调用类成员方法时则需要一个表示 Java 对象的 <code>jobject</code> 作为参数。</p><p>同时两者都需要首先提供目标 Java 方法的 JNI 签名（符合上面的 JNI 签名表规则），用来获取一个不透明的 <code>jMethodID</code> 类型，传递给 JNI 函数，用于找到目标方法，之后才能使用上述 JNI 函数调用 Java 类方法。</p><h3 id="7-3-Java-层访问实例"><a href="#7-3-Java-层访问实例" class="headerlink" title="7.3 Java 层访问实例"></a>7.3 Java 层访问实例</h3><p>下面对实际的 Java 类成员和方法进行访问和调用。</p><p>首先定义一个 Java 类，<code>JniCallExample</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JniCallExample</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> sFlag = <span class="hljs-number">256</span>;<br><br>  <span class="hljs-keyword">private</span> String mData = <span class="hljs-string">&quot;info&quot;</span>;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getData</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> mData;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> boolean <span class="hljs-title">setHello</span><span class="hljs-params">(String hello)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>.<span class="hljs-built_in">equals</span>(hello);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>JniCallExample</code> 类具有一个静态成员 <code>sFlag</code>，和成员变量 <code>mData</code>，还包含一个 <code>getData</code> 成员方法和一个静态方法。</p><p>那么下面将进行如下操作：</p><ol><li>读取 <code>sFlag</code> 的值并打印；</li><li>改变 <code>mData</code> 的值，然后调用 Java 层的 <code>getData</code> 方法，获得修改后的值；</li><li>调用 Java 层的 <code>sayHello</code> 方法，传递 <code>hello</code> 字符串，获得方法返回值。</li></ol><p>这里需要在 C&#x2F;C++ 代码中打印变量，所以需要使用 NDK 提供的 <code>liblog</code> 库，Android.mk 如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">LOCAL_PATH := $(call my-dir)<br><br>include $(CLEAR_VARS)<br><br>LOCAL_MODULE    := hello<br>LOCAL_SRC_FILES := hello.cpp<br><br><br>LOCAL_LDLIBS := -llog<br><br>include $(BUILD_SHARED_LIBRARY)<br></code></pre></td></tr></table></figure><p>下面开始编写源代码。</p><p>首先在 <code>NativeHandler</code> 类里面，声明 JNI 方法 <code>void testAccessJava(JniCallExample jniCallExample)</code>，用于调用 C&#x2F;C++ 代码来启动测试。</p><p>其中提供一个 <code>JniCallExample</code> 对象，是因为需要访问它的成员值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NativeHandler</span> &#123;<br><br>  <span class="hljs-type">static</span> &#123;<br>    System.<span class="hljs-built_in">loadLibrary</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> native <span class="hljs-type">void</span> <span class="hljs-title">testAccessJava</span><span class="hljs-params">(JniCallExample jniCallExample)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在 C++ 代码中定义对应的 JNI 方法的实现函数，并在 <code>JNI_OnLoad</code> 中注册函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *CLASS_NAME = <span class="hljs-string">&quot;io/l0neman/jniexample/NativeHandler&quot;</span>;<br><br><span class="hljs-type">static</span> JNINativeMethod gMethods[] = &#123;<br>    &#123;<span class="hljs-string">&quot;testAccessJava&quot;</span>, <span class="hljs-string">&quot;(Lio/l0neman/jniexample/JniCallExample;)V&quot;</span>, (<span class="hljs-type">void</span> *) testAccessJava&#125;,<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testAccessJava</span><span class="hljs-params">(JNIEnv *env, jobject nativeHandler)</span> </span>&#123;<br>  <br>&#125;<br><br><span class="hljs-function">JNIEXPORT jint <span class="hljs-title">JNI_OnLoad</span><span class="hljs-params">(JavaVM *vm, <span class="hljs-type">void</span> *reserved)</span> </span>&#123;<br>  JNIEnv *env = <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-keyword">if</span> (vm-&gt;<span class="hljs-built_in">GetEnv</span>((<span class="hljs-type">void</span> **) &amp;env, JNI_VERSION_1_6) != JNI_OK) &#123;<br>    <span class="hljs-keyword">return</span> JNI_ERR;<br>  &#125;<br><br>  jclass nativeHandlerClass = env-&gt;<span class="hljs-built_in">FindClass</span>(CLASS_NAME);<br>  <span class="hljs-keyword">if</span> (nativeHandlerClass == <span class="hljs-literal">nullptr</span>) &#123;<br>    <span class="hljs-keyword">return</span> JNI_ERR;<br>  &#125;<br><br>  jint methods = <span class="hljs-built_in">sizeof</span>(gMethods) / <span class="hljs-built_in">sizeof</span>(JNINativeMethod);<br>  jint ret = env-&gt;<span class="hljs-built_in">RegisterNatives</span>(nativeHandlerClass, gMethods, methods);<br>  <span class="hljs-keyword">if</span> (ret != JNI_OK) &#123;<br>    <span class="hljs-keyword">return</span> ret;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> JNI_VERSION_1_6;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面填充 <code>testAccessJava</code> 的逻辑：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *TAG = <span class="hljs-string">&quot;TAJ&quot;</span>;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">utilPrintJavaStr</span><span class="hljs-params">(JNIEnv *env, jstring jStr)</span> </span>&#123;<br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *mDataCChar = env-&gt;<span class="hljs-built_in">GetStringUTFChars</span>(jStr, <span class="hljs-literal">nullptr</span>);  <br>  <br>  __android_log_print(ANDROID_LOG_DEBUG, TAG, <span class="hljs-string">&quot;jniCallExample.mData: %s&quot;</span>, mDataCChar);<br>  env-&gt;<span class="hljs-built_in">ReleaseStringUTFChars</span>(jStr, mDataCChar);                    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testAccessJava</span><span class="hljs-params">(JNIEnv *env, jclass nativeHandler, jobject jniCallExample)</span> </span>&#123;<br>  jclass jniCallExampleClass = env-&gt;<span class="hljs-built_in">FindClass</span>(<span class="hljs-string">&quot;io/l0neman/jniexample/JniCallExample&quot;</span>);<br><br>  jfieldID sFlagStaticFieldId = env-&gt;<span class="hljs-built_in">GetStaticFieldID</span>(jniCallExampleClass, <span class="hljs-string">&quot;sFlag&quot;</span>, <span class="hljs-string">&quot;I&quot;</span>);<br>  <br>  jint sFlag = env-&gt;<span class="hljs-built_in">GetStaticIntField</span>(jniCallExampleClass, sFlagStaticFieldId);<br>  __android_log_print(ANDROID_LOG_DEBUG, TAG, <span class="hljs-string">&quot;JniCallExample.sFlag: %d&quot;</span>, sFlag);<br><br>  jfieldID mDataFieldId = env-&gt;<span class="hljs-built_in">GetFieldID</span>(jniCallExampleClass, <span class="hljs-string">&quot;mData&quot;</span>, <span class="hljs-string">&quot;Ljava/lang/String;&quot;</span>);<br>  <br>  jstring newData = env-&gt;<span class="hljs-built_in">NewStringUTF</span>(<span class="hljs-string">&quot;data&quot;</span>);<br>  <br>  env-&gt;<span class="hljs-built_in">SetObjectField</span>(jniCallExample, mDataFieldId, newData);<br><br>  jmethodID getDataMethodId = env-&gt;<span class="hljs-built_in">GetMethodID</span>(jniCallExampleClass, <span class="hljs-string">&quot;getData&quot;</span>, <span class="hljs-string">&quot;()Ljava/lang/String;&quot;</span>);<br>  <br>  jstring newMData = (jstring) env-&gt;<span class="hljs-built_in">CallObjectMethod</span>(jniCallExample, getDataMethodId);<br>  <span class="hljs-built_in">utilPrintJavaStr</span>(env, newMData);<br><br>  jmethodID setHelloStaticMethodId = env-&gt;<span class="hljs-built_in">GetStaticMethodID</span>(jniCallExampleClass, <span class="hljs-string">&quot;setHello&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/String;)Z&quot;</span>);<br>  <br>  jstring helloParam = env-&gt;<span class="hljs-built_in">NewStringUTF</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>  <br>  jboolean isSetHello = (jboolean) env-&gt;<span class="hljs-built_in">CallStaticBooleanMethod</span>(jniCallExampleClass, setHelloStaticMethodId, helloParam);<br>  __android_log_print(ANDROID_LOG_DEBUG, TAG, <span class="hljs-string">&quot;isSetHello %d&quot;</span>, isSetHello);<br>&#125;<br></code></pre></td></tr></table></figure><p>打印出如下结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">JniCallExample.sFlag: <span class="hljs-number">256</span><br>jniCallExample.mData: data<br>isSetHello <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>其中注释 <code>Java: xxx</code> 表示与 Java 代码有相同作用。</p><p>其中包含一部分对于字符串的操作：</p><p><code>env-&gt;NewStringUTF(&quot;data&quot;)</code> 用于创建一个 Java 字符串（new String()），它的内存由 Java 虚拟机管理，它使用 <code>jstring</code> 类型来描述，是一个 JNI 提供的不透明类型，用于映射一个 Java 字符串。每种 Java 类型都有对应的映射类型（下面会提供映射表），这里用作 Java 变量来给 Java 变量赋值或者作为参数传递。</p><p><code>env-&gt;GetStringUTFChars(jStr, nullptr);</code> 用于从 Java 字符串中取得 C 形式的 Modified_UTF-8（下文介绍）字符串，它将会在 native 层分配内存，而不是由 Java 虚拟机管理，所以使用后需要手动使用 <code>ReleaseStringUTFChars</code> 释放。</p><h3 id="7-4-访问优化"><a href="#7-4-访问优化" class="headerlink" title="7.4 访问优化"></a>7.4 访问优化</h3><p>在对 Java 层进行访问时，不管是访问 Java 类成员还是调用 Java 方法，都需要首先使用 <code>FindClass</code> 找到目标 Java 类，然后获取对应的成员 ID 和方法 ID， 对于 <code>FindClass</code> 和查找相关 ID 的函数，每次调用它们可能都需要进行多次的字符串比较，而使用这些 ID 去访问对于的 Java 类成员和方法速度却是很快的。</p><p>那么如果需要多次访问相同的 Java 目标，那么考虑将这些 <code>jclass</code>（FindClass 的结果）和相关 ID 缓存起来。 这些变量在被访问的 Java 类被卸载之前保证是有效的。只有在与 ClassLoader 关联的所有类都满足垃圾回收条件时，系统才会卸载这些类，这种情况比较少见，但在 Android 中是有可能出现的。</p><p>Android 推荐的方法是，在 Java 类中声明一个名叫 <code>nativeInit</code> 的 JNI 方法，在类的静态块内调用，这个 JNI 方法就负责提前缓存要使用的 Java 类型，那么一个类被加载时，<code>nativeInit</code> 就会被调用。</p><p>可以在 Android 系统源码中看到许多名叫 <code>nativeInit</code> 的 JNI 方法，它们就是负责此用途的。</p><p>一般使用 <code>static</code> 结构来缓存这些 ID 和 <code>jclass</code>，<code>jclass</code> 作为 Java 引用，需要使用 <code>NewGlobalRef</code> 函数创建一个全局引用来保护它不被回收。</p><p>那么现在改进之前的 Java 访问实例，如下：</p><p>首先在 <code>NativeHandler</code> 中增加 <code>nativeInit</code> 方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NativeHandler</span> &#123;<br><br>  <span class="hljs-type">static</span> &#123;<br>    System.<span class="hljs-built_in">loadLibrary</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-built_in">nativeInit</span>();<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> native <span class="hljs-type">void</span> <span class="hljs-title">nativeInit</span><span class="hljs-params">()</span></span>;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> native <span class="hljs-type">void</span> <span class="hljs-title">testAccessJava</span><span class="hljs-params">(JniCallExample jniCallExample)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后是源代码，注册部分只修改 <code>JNINativeMethod</code> 数组即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">static</span> JNINativeMethod gMethods[] = &#123;<br>    &#123;<span class="hljs-string">&quot;testAccessJava&quot;</span>, <span class="hljs-string">&quot;(Lio/l0neman/jniexample/JniCallExample;)V&quot;</span>, (<span class="hljs-type">void</span> *) testAccessJava&#125;,<br>    &#123;<span class="hljs-string">&quot;nativeInit&quot;</span>,     <span class="hljs-string">&quot;()V&quot;</span>,                                       (<span class="hljs-type">void</span> *) nativeInit&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>然后是 <code>nativeInit</code> 的逻辑和修改过的 <code>testAccessJava</code> 函数的实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">JniCallExampleHolder</span> &#123;<br>    jclass jniCallExampleClass;<br>    jfieldID sFlagStaticFieldId;<br>    jfieldID mDataFieldId;<br>    jmethodID getDataMethodId;<br>    jmethodID setHelloStaticMethodId;<br>&#125;;<br><br><span class="hljs-type">static</span> JniCallExampleHolder gJniCallExampleHolder;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">nativeInit</span><span class="hljs-params">(JNIEnv *env, jclass clazz)</span> </span>&#123;<br>  jclass jniCallExampleClass = env-&gt;<span class="hljs-built_in">FindClass</span>(<span class="hljs-string">&quot;io/l0neman/jniexample/JniCallExample&quot;</span>);<br>  gJniCallExampleHolder.jniCallExampleClass = (jclass) env-&gt;<span class="hljs-built_in">NewGlobalRef</span>(jniCallExampleClass);   <br>  gJniCallExampleHolder.sFlagStaticFieldId = env-&gt;<span class="hljs-built_in">GetStaticFieldID</span>(jniCallExampleClass, <span class="hljs-string">&quot;sFlag&quot;</span>, <span class="hljs-string">&quot;I&quot;</span>);;<br>  gJniCallExampleHolder.mDataFieldId = env-&gt;<span class="hljs-built_in">GetFieldID</span>(jniCallExampleClass, <span class="hljs-string">&quot;mData&quot;</span>, <span class="hljs-string">&quot;Ljava/lang/String;&quot;</span>);<br>  gJniCallExampleHolder.getDataMethodId = env-&gt;<span class="hljs-built_in">GetMethodID</span>(jniCallExampleClass, <span class="hljs-string">&quot;getData&quot;</span>, <span class="hljs-string">&quot;()Ljava/lang/String;&quot;</span>);;<br>  gJniCallExampleHolder.setHelloStaticMethodId = env-&gt;<span class="hljs-built_in">GetStaticMethodID</span>(jniCallExampleClass, <span class="hljs-string">&quot;setHello&quot;</span>, <span class="hljs-string">&quot;(Ljava/lang/String;)Z&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testAccessJava</span><span class="hljs-params">(JNIEnv *env, jclass nativeHandler, jobject jniCallExample)</span> </span>&#123;<br><br>  <br>  jint sFlag = env-&gt;<span class="hljs-built_in">GetStaticIntField</span>(gJniCallExampleHolder.jniCallExampleClass,<br>                                      gJniCallExampleHolder.sFlagStaticFieldId);<br>  __android_log_print(ANDROID_LOG_DEBUG, TAG, <span class="hljs-string">&quot;JniCallExample.sFlag: %d&quot;</span>, sFlag);<br><br>  <br>  jstring newData = env-&gt;<span class="hljs-built_in">NewStringUTF</span>(<span class="hljs-string">&quot;data&quot;</span>);<br>  <br>  env-&gt;<span class="hljs-built_in">SetObjectField</span>(jniCallExample, gJniCallExampleHolder.mDataFieldId, newData);<br><br>  <br>  jstring newMData = (jstring) env-&gt;<span class="hljs-built_in">CallObjectMethod</span>(jniCallExample, gJniCallExampleHolder.getDataMethodId);<br>  <span class="hljs-built_in">utilPrintJavaStr</span>(env, newMData);<br><br>  <br>  jstring helloParam = env-&gt;<span class="hljs-built_in">NewStringUTF</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>  <br>  jboolean isSetHello = (jboolean) env-&gt;<span class="hljs-built_in">CallStaticBooleanMethod</span>(gJniCallExampleHolder.jniCallExampleClass,<br>                                                                gJniCallExampleHolder.setHelloStaticMethodId,<br>                                                                helloParam);<br>  __android_log_print(ANDROID_LOG_DEBUG, TAG, <span class="hljs-string">&quot;isSetHello %d&quot;</span>, isSetHello);<br>&#125;<br></code></pre></td></tr></table></figure><p>其中有一个地方使用了 <code>env-&gt;NewGlobalRef</code> 建立了一个全局引用，它会保护这个 <code>jclass</code> 不会在 JNI 函数执行完之后被回收，注意需要在不使用的时候使用 <code>env-&gt;DeleteGlobalRef</code> 释放引用，例如 <code>JNI_OnUnload</code> 中。</p><h3 id="7-5-JNI-类型"><a href="#7-5-JNI-类型" class="headerlink" title="7.5 JNI 类型"></a>7.5 JNI 类型</h3><p>每种 Java 类型在 JNI 中都有对应的本地数据类型，C&#x2F;C++ 通过 JNI 方法与 Java 层进行交互时，均是使用这些类型进行参数传递，此时虚拟机再根据每种类型翻译为相应的 Java 类型传递给 Java 层方法.</p><p>还有一些特殊的数据类型用来存储 Java 方法 ID 和类成员 ID。</p><h4 id="7-5-1-基本数据类型"><a href="#7-5-1-基本数据类型" class="headerlink" title="7.5.1 基本数据类型"></a>7.5.1 基本数据类型</h4><table><thead><tr><th>Java 类型</th><th>本地类型</th><th>说明</th></tr></thead><tbody><tr><td>boolean</td><td>jboolean</td><td>unsigned 8 bits</td></tr><tr><td>byte</td><td>jbyte</td><td>signed 8 bits</td></tr><tr><td>char</td><td>jchar</td><td>signed 16 bits</td></tr><tr><td>short</td><td>jshort</td><td>signed 16 bits</td></tr><tr><td>int</td><td>jint</td><td>signed 32 bits</td></tr><tr><td>long</td><td>jlong</td><td>signed 64 bits</td></tr><tr><td>float</td><td>jfloat</td><td>32 bits</td></tr><tr><td>double</td><td>jdouble</td><td>64 bits</td></tr><tr><td>void</td><td>void</td><td>无</td></tr></tbody></table><p><code>jboolean</code> 的两种取值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> JNI_FALSE  0 </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> JNI_TRUE   1</span><br></code></pre></td></tr></table></figure><p><code>jsize</code> 类型用于描述数组大小或者索引。</p><p>从 <code>jni.h</code> 中看它们和真实 C&#x2F;C++ 数据类型的对应关系：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">uint8_t</span>  jboolean; <br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int8_t</span>   jbyte;    <br><span class="hljs-keyword">typedef</span> <span class="hljs-type">uint16_t</span> jchar;    <br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int16_t</span>  jshort;   <br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int32_t</span>  jint;     <br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int64_t</span>  jlong;    <br><span class="hljs-keyword">typedef</span> <span class="hljs-type">float</span>    jfloat;   <br><span class="hljs-keyword">typedef</span> <span class="hljs-type">double</span>   jdouble;  <br><br><br><span class="hljs-keyword">typedef</span> jint     jsize;<br></code></pre></td></tr></table></figure><h4 id="7-5-2-引用类型"><a href="#7-5-2-引用类型" class="headerlink" title="7.5.2 引用类型"></a>7.5.2 引用类型</h4><p>在 C++ 中，Java 引用类型使用一些类表示，它们的继承关系如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">jobject</span>                     (所有 Java 对象)<br> |<br> +-- <span class="hljs-built_in">jclass</span>                (java.lang.Class 对象)<br> +-- <span class="hljs-built_in">jstring</span>               (java.lang.String 对象)<br> +-- <span class="hljs-built_in">jarray</span>                (数组)<br> |    |<br> |    +-- <span class="hljs-built_in">jobjectArray</span>     (object 数组)<br> |    +-- <span class="hljs-built_in">jbooleanArray</span>    (boolean 数组)<br> |    +-- <span class="hljs-built_in">jbyteArray</span>       (byte 数组)<br> |    +-- <span class="hljs-built_in">jcharArray</span>       (<span class="hljs-type">char</span> 数组)<br> |    +-- <span class="hljs-built_in">jshortArray</span>      (<span class="hljs-type">short</span> 数组)<br> |    +-- <span class="hljs-built_in">jintArray</span>        (<span class="hljs-type">int</span> 数组)<br> |    +-- <span class="hljs-built_in">jlongArray</span>       (<span class="hljs-type">long</span> 数组)<br> |    +-- <span class="hljs-built_in">jfloatArray</span>      (<span class="hljs-type">float</span> 数组)<br> |    +-- <span class="hljs-built_in">jdoubleArray</span>     (<span class="hljs-type">double</span> 数组)<br> |<br> +- <span class="hljs-built_in">jthrowable</span>             (java.lang.Throwable 对象)<br></code></pre></td></tr></table></figure><p>源码中定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">_jobject</span> &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">_jclass</span> : <span class="hljs-keyword">public</span> _jobject &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">_jstring</span> : <span class="hljs-keyword">public</span> _jobject &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">_jarray</span> : <span class="hljs-keyword">public</span> _jobject &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">_jobjectArray</span> : <span class="hljs-keyword">public</span> _jarray &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">_jbooleanArray</span> : <span class="hljs-keyword">public</span> _jarray &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">_jbyteArray</span> : <span class="hljs-keyword">public</span> _jarray &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">_jcharArray</span> : <span class="hljs-keyword">public</span> _jarray &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">_jshortArray</span> : <span class="hljs-keyword">public</span> _jarray &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">_jintArray</span> : <span class="hljs-keyword">public</span> _jarray &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">_jlongArray</span> : <span class="hljs-keyword">public</span> _jarray &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">_jfloatArray</span> : <span class="hljs-keyword">public</span> _jarray &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">_jdoubleArray</span> : <span class="hljs-keyword">public</span> _jarray &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">_jthrowable</span> : <span class="hljs-keyword">public</span> _jobject &#123;&#125;;<br><br><span class="hljs-keyword">typedef</span> _jobject*       jobject;<br><span class="hljs-keyword">typedef</span> _jclass*        jclass;<br><span class="hljs-keyword">typedef</span> _jstring*       jstring;<br><span class="hljs-keyword">typedef</span> _jarray*        jarray;<br><span class="hljs-keyword">typedef</span> _jobjectArray*  jobjectArray;<br><span class="hljs-keyword">typedef</span> _jbooleanArray* jbooleanArray;<br><span class="hljs-keyword">typedef</span> _jbyteArray*    jbyteArray;<br><span class="hljs-keyword">typedef</span> _jcharArray*    jcharArray;<br><span class="hljs-keyword">typedef</span> _jshortArray*   jshortArray;<br><span class="hljs-keyword">typedef</span> _jintArray*     jintArray;<br><span class="hljs-keyword">typedef</span> _jlongArray*    jlongArray;<br><span class="hljs-keyword">typedef</span> _jfloatArray*   jfloatArray;<br><span class="hljs-keyword">typedef</span> _jdoubleArray*  jdoubleArray;<br><span class="hljs-keyword">typedef</span> _jthrowable*    jthrowable;<br><span class="hljs-keyword">typedef</span> _jobject*       jweak;<br></code></pre></td></tr></table></figure><p>在 C 语言中，所有 JNI 引用类型都与 jobject 的定义相同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">void</span>*           jobject;<br><span class="hljs-keyword">typedef</span> jobject         jclass;<br><span class="hljs-keyword">typedef</span> jobject         jstring;<br><span class="hljs-keyword">typedef</span> jobject         jarray;<br><span class="hljs-keyword">typedef</span> jarray          jobjectArray;<br><span class="hljs-keyword">typedef</span> jarray          jbooleanArray;<br><span class="hljs-keyword">typedef</span> jarray          jbyteArray;<br><span class="hljs-keyword">typedef</span> jarray          jcharArray;<br><span class="hljs-keyword">typedef</span> jarray          jshortArray;<br><span class="hljs-keyword">typedef</span> jarray          jintArray;<br><span class="hljs-keyword">typedef</span> jarray          jlongArray;<br><span class="hljs-keyword">typedef</span> jarray          jfloatArray;<br><span class="hljs-keyword">typedef</span> jarray          jdoubleArray;<br><span class="hljs-keyword">typedef</span> jobject         jthrowable;<br><span class="hljs-keyword">typedef</span> jobject         jweak;<br></code></pre></td></tr></table></figure><h4 id="7-5-3-方法和类成员-ID"><a href="#7-5-3-方法和类成员-ID" class="headerlink" title="7.5.3 方法和类成员 ID"></a>7.5.3 方法和类成员 ID</h4><p>它们是不透明结构体指针类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">_jfieldID</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_jfieldID</span> *jfieldID;<br> <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">_jmethodID</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_jmethodID</span> *jmethodID;<br></code></pre></td></tr></table></figure><h4 id="7-5-4-数组元素"><a href="#7-5-4-数组元素" class="headerlink" title="7.5.4 数组元素"></a>7.5.4 数组元素</h4><p><code>jvalue</code> 用于作为参数数组中的元素类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">union</span> <span class="hljs-title class_">jvalue</span> &#123;<br>    jboolean    z;<br>    jbyte       b;<br>    jchar       c;<br>    jshort      s;<br>    jint        i;<br>    jlong       j;<br>    jfloat      f;<br>    jdouble     d;<br>    jobject     l;<br>&#125; jvalue;<br></code></pre></td></tr></table></figure><h3 id="7-6-引用管理"><a href="#7-6-引用管理" class="headerlink" title="7.6 引用管理"></a>7.6 引用管理</h3><p>Java 对象在 JNI 中有两种引用方式，一种是局部引用；一种是全局引用。</p><h4 id="7-6-1-局部引用"><a href="#7-6-1-局部引用" class="headerlink" title="7.6.1 局部引用"></a>7.6.1 局部引用</h4><p>Java 层通过 JNI 方法传递给 C&#x2F;C++ 函数的每个对象参数，以及 C&#x2F;C++ 通过 JNI 函数（<code>Call&lt;type&gt;Method</code>）调用接收的 Java 方法的对象返回值都属于局部引用。</p><p>局部引用仅在当前线程中的当前 C&#x2F;C++ 函数运行期间有效。在 C&#x2F;C++ 函数返回后，即使对象本身继续存在，该引用也无效。</p><p>局部引用适用于 <code>jobject</code> 的所有子类，包括 <code>jclass</code>、<code>jstring</code> 和 <code>jarray</code>。</p><h4 id="7-6-2-全局引用"><a href="#7-6-2-全局引用" class="headerlink" title="7.6.2 全局引用"></a>7.6.2 全局引用</h4><p>创建全局引用只能使用 <code>NewGlobalRef</code> 和 <code>NewWeakGlobalRef</code> 函数。</p><p>如果希望长时间的持有某个引用，那么必须使用全局引用，使用 <code>NewGlobalRef</code> 函数时将局部引用作为参数传入，换取全局引用。在调用 <code>DeleteGlobalRef</code> 删除全局引用之前，此引用保证有效。</p><p>通常用于缓存 <code>FindClass</code> 返回的 <code>jclass</code>，就像前面的 Java 访问优化中所做的措施一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">jclass localClass = env-&gt;<span class="hljs-built_in">FindClass</span>(<span class="hljs-string">&quot;MyClass&quot;</span>);<br>jclass globalClass = <span class="hljs-built_in">reinterpret_cast</span>&lt;jclass&gt;(env-&gt;<span class="hljs-built_in">NewGlobalRef</span>(localClass));<br></code></pre></td></tr></table></figure><h4 id="7-6-3-提示"><a href="#7-6-3-提示" class="headerlink" title="7.6.3 提示"></a>7.6.3 提示</h4><p>对于同一个对象的引用可能存在多个不同的值，例如，对于同一个对象多次调用 <code>NewGlobalRef</code> 所返回的值可能不同。</p><p>如果需要比较两个引用是否指向同一个对象，必须使用 <code>IsSameObject</code> 函数，切勿在 C&#x2F;C++ 代码中使用 <code>==</code> 比较各个引用。</p><p>在两次调用 <code>NewGlobalRef</code> 对同一个对象创建全局引用时，表示这个对象的 32 位值可能不同；而在多次调用 <code>NewGlobalRef</code> 创建不同对象的全局引用时，它们可能具有相同的 32 位值，所以不能将 <code>jobject</code> 用作 key 使用。</p><p>不要过度分配局部引用，如果需要创建大量引用，应该主动调用 <code>DeleteLocalRef</code> 删除它们，而不是期望 JNI 自动删除。JNI 默认实现只能保留 16 个局部引用，如果需要保存更多数量，可以按照需要删除，或使用 <code>EnsureLocalCapacity/PushLocalFrame</code> 申请保留更多引用数量。</p><p><code>jfieldID</code> 和 <code>jmethodID</code> 为不透明类型，不属于对象引用，所以不能使用 <code>NewGlobalRef</code> 保护。<code>GetStringUTFChars</code> 和 <code>GetByteArrayElements</code> 返回的原始数据指针也不属于对象。</p><p>一种特殊情况是，如果使用 <code>AttachCurrentThread</code> 附加到 C&#x2F;C++ 线程，那么在线程分离之前，运行中的代码一定不会自动释放局部引用。代码创建的任何局部引用都必须手动删除。通常，在循环中创建局部引用的任何 C&#x2F;C++ 代码需要执行某些手动删除操作。</p><p>谨慎使用全局引用。全局引用不可避免，但它们很难调试，并且可能会导致难以诊断的内存（不良）行为。在所有其他条件相同的情况下，全局引用越少，解决方案的效果可能越好。</p><p>对 Java 字符串和数组的访问方法。访问这些数据是 JNI 开发的基础。</p><h2 id="8-java常用数据访问"><a href="#8-java常用数据访问" class="headerlink" title="8. java常用数据访问"></a>8. java常用数据访问</h2><h3 id="8-1-访问字符串"><a href="#8-1-访问字符串" class="headerlink" title="8.1 访问字符串"></a>8.1 访问字符串</h3><p>访问字符串有如下两种情况：</p><ol><li>Java 层调用 JNI 方法，String 对象以 <code>jstring</code> 的形式传入 JNI 方法，此时 C&#x2F;C++ 语言接收使用；</li><li>C&#x2F;C++ 产生字符串数据，返回给 Java 层使用。</li></ol><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">final</span> String hello = NativeHandler.<span class="hljs-built_in">testAccessString</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">jstring <span class="hljs-title">testAccessString</span><span class="hljs-params">(JNIEnv *env, jclass clazz, jstring hello)</span> </span>&#123;<br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *stringChars = env-&gt;<span class="hljs-built_in">GetStringUTFChars</span>(hello, <span class="hljs-literal">nullptr</span>);  <br>  __android_log_print(ANDROID_LOG_DEBUG, TAG, <span class="hljs-string">&quot;java string: %s&quot;</span>, stringChars);<br>  env-&gt;<span class="hljs-built_in">ReleaseStringUTFChars</span>(hello, stringChars);                    <br><br>  <span class="hljs-keyword">return</span> env-&gt;<span class="hljs-built_in">NewStringUTF</span>(<span class="hljs-string">&quot;result&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="8-1-1-获取字符串"><a href="#8-1-1-获取字符串" class="headerlink" title="8.1.1 获取字符串"></a>8.1.1 获取字符串</h4><p><code>GetStringUTFChars</code> 将返回 C&#x2F;C++ 语言可以直接使用的 <a href="https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/types.html#wp16542">Modified_UTF-8</a> 格式字符串（Modified_UTF-8 格式是 JNI 提供的优化后的 UTF-8 格式字符串，优化后的编码对 C 代码友好，因为它将 <code>\u0000</code> 编码为 <code>0xc0 0x80</code>，而不是 <code>0x00</code>。这样做的好处是，可以依靠以 <code>\0</code> 终止的 C 样式字符串，非常适合与标准 libc 字符串函数配合使用。但缺点是，无法将任意 UTF-8 的数据传递给 JNI 函数）。</p><p>在使用 <code>GetStringUTFChars</code> 获取字符串后，JavaVM 为字符串在 native 层分配了内存，在字符串使用完毕后，必须使用 <code>ReleaseStringUTFChars</code> 释放内存，否则将会造成内存泄漏。</p><p>从 C&#x2F;C++ 获取 Java 字符串的长度有两种方式，可直接使用 <code>GetStringUTFLength</code> 对 <code>jstring</code> 计算长度：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">jstring hello;<br>jsize utfLength = env-&gt;<span class="hljs-built_in">GetStringUTFLength</span>(hello);<br></code></pre></td></tr></table></figure><p>或者使用 C&#x2F;C++ 的 <code>strlen</code> 计算：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *stringChars = env-&gt;<span class="hljs-built_in">GetStringUTFChars</span>(hello, <span class="hljs-literal">nullptr</span>);<br><span class="hljs-type">size_t</span> utfLength = <span class="hljs-built_in">strlen</span>(stringChars);<br></code></pre></td></tr></table></figure><p><code>GetStringUTFChars</code> 函数的第 2 个参数是一个 <code>jboolean</code> 类型的指针，表示关心是否创建了字符串的副本，如果创建了字符串的副本它会返回 <code>JNI_TRUE</code>，否则为 <code>JNI_FALSE</code>，不管是否创建，都需要 Release 操作，所以一般不会关心它的结果，传递 <code>nullptr</code> 即可（C 语言传递 <code>NULL</code>）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">jboolean isCopy;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *stringChars = env-&gt;<span class="hljs-built_in">GetStringUTFChars</span>(hello,);  <br><span class="hljs-keyword">if</span> (isCopy == JNI_TRUE) &#123;<br>  <br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isCopy == JNI_FALSE) &#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="8-1-2-提示"><a href="#8-1-2-提示" class="headerlink" title="8.1.2 提示"></a>8.1.2 提示</h4><p>JNI 还提供了 <code>GetStringChars</code> 函数，它返回的是 UTF-16 字符串，使用 UTF-16 字符串执行操作通常会更快，但是 UTF-16 字符串不是以零终止的，并且允许使用 <code>\u0000</code>，因此需要保留字符串长度和返回的 <code>jchar</code> 指针。</p><p>一般的开发中几乎都使用 <code>GetStringUTFChars</code> 获取字符串。</p><h4 id="8-1-3-返回字符串"><a href="#8-1-3-返回字符串" class="headerlink" title="8.1.3 返回字符串"></a>8.1.3 返回字符串</h4><p>如果需要返回给 Java 层字符串，使用 <code>env-&gt;NewStringUTF(&quot;result&quot;)</code> 即可，JavaVM 将会基于 C 字符串创建一个新的 <code>String</code> 的对象，它的内存由虚拟机管理。</p><p>注意传递给 <code>NewStringUTF</code> 的数据必须采用 Modified_UTF-8 格式。一种常见的错误是从文件或网络数据流中读取字符数据，在未过滤的情况下将其传递给 <code>NewStringUTF</code>。除非确定数据是有效的 Modified_UTF-8 格式（或 7 位 ASCII，这是一个兼容子集），否则需要剔除无效字符或将它们转换为适当的 Modified_UTF-8 格式。如果不这样做，UTF-16 转换可能会产生意外的结果（Java 语言使用的是 UTF-16）。默认状态下 CheckJNI 会为模拟器启用，它会扫描并在收到无效字符串输入时中止虚拟机。</p><h3 id="8-2-访问数组"><a href="#8-2-访问数组" class="headerlink" title="8.2 访问数组"></a>8.2 访问数组</h3><p>和访问 Java 成员类似，JNI 提供了一系列访问数组的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">GetIntArrayElements</span>();<br><span class="hljs-built_in">GetBooleanArrayElements</span>();<br><span class="hljs-built_in">GetDoubleArrayElements</span>();<br></code></pre></td></tr></table></figure><p>总结为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Get&lt;type&gt;<span class="hljs-built_in">ArrayElements</span>();<br></code></pre></td></tr></table></figure><p>其中 <code>&lt;type&gt;</code> 中只能是 Java 的基本类型，不包含 <code>String</code> 以及其他引用类型。</p><p>下面分别使用 C&#x2F;C++ 获取 Java 传递的 <code>int</code> 类型和 <code>String</code> 的数组，作为获取 Java 基本类型和引用类型数组的典型示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span>[] array0 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>String[] array1 = &#123;<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-string">&quot;e&quot;</span>&#125;;<br>NativeHandler.<span class="hljs-built_in">testAccessArray</span>(array0, array1);<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testAccessArray</span><span class="hljs-params">(JNIEnv *env, jclass clazz, jintArray array0, jobjectArray array1)</span> </span>&#123;<br>  <br>  jint *elements0 = env-&gt;<span class="hljs-built_in">GetIntArrayElements</span>(array0, <span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-keyword">if</span>(elements0 != <span class="hljs-literal">nullptr</span>) &#123;<br>    jsize array0Length = env-&gt;<span class="hljs-built_in">GetArrayLength</span>(array0);<br>    <span class="hljs-keyword">for</span> (jint i = <span class="hljs-number">0</span>; i &lt; array0Length; i++) &#123;<br>      __android_log_print(ANDROID_LOG_DEBUG, TAG, <span class="hljs-string">&quot;array0[%d] = %d&quot;</span>, i, elements0[i]);<br>    &#125;<br><br>    env-&gt;<span class="hljs-built_in">ReleaseIntArrayElements</span>(array0, elements0, <span class="hljs-number">0</span>);<br>  &#125;<br><br>  <br>  jsize array1Length = env-&gt;<span class="hljs-built_in">GetArrayLength</span>(array1);<br>  <span class="hljs-keyword">for</span> (jint i = <span class="hljs-number">0</span>; i &lt; array1Length; i++) &#123;<br>    jstring element = (jstring) env-&gt;<span class="hljs-built_in">GetObjectArrayElement</span>(array1, i);<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *chars = env-&gt;<span class="hljs-built_in">GetStringUTFChars</span>(element, <span class="hljs-literal">nullptr</span>);  <br>    __android_log_print(ANDROID_LOG_DEBUG, TAG, <span class="hljs-string">&quot;array1[%d] = %s&quot;</span>, i, chars);<br>    env-&gt;<span class="hljs-built_in">ReleaseStringUTFChars</span>(element, chars);                    <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">array0[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>array0[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span><br>array0[<span class="hljs-number">2</span>] = <span class="hljs-number">3</span><br>array0[<span class="hljs-number">3</span>] = <span class="hljs-number">4</span><br>array0[<span class="hljs-number">4</span>] = <span class="hljs-number">5</span><br>array1[<span class="hljs-number">0</span>] = a<br>array1[<span class="hljs-number">1</span>] = b<br>array1[<span class="hljs-number">2</span>] = c<br>array1[<span class="hljs-number">3</span>] = d<br>array1[<span class="hljs-number">4</span>] = e<br></code></pre></td></tr></table></figure><p>代码比较清晰，可以看到基本类型的数组，直接可以使用 <code>Get&lt;type&gt;ArrayElements(...)</code> 获得一个数组的首地址，使用 <code>GetArrayLength</code> 获取数组长度后，即可像 C&#x2F;C++ 原生数组一样使用指针遍历每一个元素。</p><p>在对原生类型的数组访问之后，需要调用 <code>Release&lt;type&gt;ArrayElements</code> 请求释放内存。</p><p>对象数组则没有提供 <code>Get&lt;type&gt;ArrayElements(...)</code> 的方法，但是它提供了获取单个元素的 <code>GetObjectArrayElement</code> 方法，那么也可以使用循环获取每个 <code>jobject</code> 元素，然后转换为原本的类型。</p><p>如果需要更改原生类型的数组元素值，直接修改获取 C&#x2F;C++ 数组元素的值，JNI 将会把值复制回原始数据区中。</p><p>如果需要更改引用类型的数组元素值，JNI 提供了 <code>SetObjectArrayElement</code> 函数，可直接修改原始元素对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">env-&gt;<span class="hljs-built_in">SetObjectArrayElement</span>(array1, <span class="hljs-number">1</span>, env-&gt;<span class="hljs-built_in">NewStringUTF</span>(<span class="hljs-string">&quot;hello&quot;</span>));<br></code></pre></td></tr></table></figure><h4 id="8-2-1-提示"><a href="#8-2-1-提示" class="headerlink" title="8.2.1 提示"></a>8.2.1 提示</h4><p>JNI 为了在不限制虚拟机实现的情况下使接口尽可能高效，允许 <code>Get&lt;type&gt;ArrayElements(...)</code> 函数的调用在运行时直接返回指向实际数据元素的指针，或者分配一些内存创建数据的副本。</p><p>在调用 Release 之前，返回的原生数组指针保证可用，如果没有创建数据的副本，那么原生数组将被固定，在虚拟机整理内存碎片时不会调整原生数组的位置，Release 的时候需要进行判空操作，防止在 Get 数组失败时 Release 空指针。</p><p><code>ReleaseIntArrayElements</code> 函数的最后一个函数的 <code>mode</code> 参数有三个，运行时执行的操作取决于返回的指针指向实际数据还是指向数据副本。</p><p><code>mode</code> 以及对应的 Release 行为：</p><ol><li><code>0</code></li></ol><p>实际数据：取消数组元素固定。<br>数据副本：将数据复制回原始数据，释放包含副本的缓冲区。</p><ol start="2"><li><code>JNI_COMMIT</code></li></ol><p>实际数据：不执行任何操作。<br>数据副本：将数据复制回原始数据，不释放包含副本的缓冲区。</p><ol start="3"><li><code>JNI_ABORT</code></li></ol><p>实际数据：取消数组元素固定，不中止早期的写入数据。<br>数据副本：释放包含相应副本的缓冲区；对该副本所做的任何更改都会丢失。</p><p>通常传递 <code>0</code> 来保持固定和复制数组的行为一致，其他选项可以用来更好地控制内存，需要谨慎传递。</p><p>其中 <code>GetIntArrayElements</code> 的第 2 个参数，它类似于 <code>GetStringUTFChars</code> 的第 2 个参数，也是 <code>isCopy</code>，表示获取数组时是否创建了数据副本。</p><p>通常检查 <code>isCopy</code> 标志的原因有两个：</p><ol><li>了解是否需要在对数组进行更改后使用 <code>JNI_COMMIT</code> 调用 Release 函数，如果需要在对数组进行更改和仅使用数组内容的代码之间切换，则可以跳过释放缓冲区提交（更改数组数据后需要继续访问数组）；</li><li>有效处理 <code>JNI_ABORT</code>，考虑可能需要获取一个数组，然后进行适当修改后，将数组的一部分传递给其他函数使用，最后舍弃对数组的修改。如果知道 JNI 为数组创建了副本，那么就不需要自己创建一个可被修改的副本，如果 JNI 传递的是实际数据的指针，那么就需要自己创建数组的副本。</li></ol><h4 id="8-2-2-注意"><a href="#8-2-2-注意" class="headerlink" title="8.2.2 注意"></a>8.2.2 注意</h4><p>不能认为 <code>*isCopy</code> 为 <code>JNI_FALSE</code> 时就不需要调用 Release，这是一种常见误区。</p><p>如果 JNI 没有分配任何副本缓冲区，返回指向实际数据的指针，那么虚拟机必须固定实际数组的内存，此时垃圾回收器将不能移动内存，造成内存不能释放。</p><p><code>JNI_COMMIT</code> 标记不会释放数组，最终还需要使用其他标记再次调用 Release。</p><h4 id="8-2-3-数组区域调用"><a href="#8-2-3-数组区域调用" class="headerlink" title="8.2.3 数组区域调用"></a>8.2.3 数组区域调用</h4><p>如果只想复制 Java 数组，使用 <code>Get&lt;type&gt;ArrayRegion</code> 更好。</p><p>通常使用 <code>Get&lt;type&gt;ArrayElements</code> 时，如果需要复制数组数据到外部的缓冲区中，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">jbyte* data = env-&gt;<span class="hljs-built_in">GetByteArrayElements</span>(array, <span class="hljs-literal">NULL</span>);<br><span class="hljs-keyword">if</span> (data != <span class="hljs-literal">nullptr</span>) &#123;<br>  <span class="hljs-built_in">memcpy</span>(buffer, data, len);<br>  env-&gt;<span class="hljs-built_in">ReleaseByteArrayElements</span>(array, data, JNI_ABORT);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样会复制数组 <code>len</code> 长度的字节到 <code>buffer</code> 中，然后释放数组内存。其中 Get 调用可能会返回实际数组或者实际数组的副本，取决于运行时的情况，代码复制数据（那么上面的代码可能是第 2 次复制），那么这种情况下，使用 <code>JNI_ABORT</code> 确保不会再出现第 3 次复制。</p><p>使用 <code>Get&lt;type&gt;ArrayRegion</code> 函数不仅可以完成相同操作，而且不必考虑 Release 调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">env-&gt;<span class="hljs-built_in">GetByteArrayRegion</span>(array, <span class="hljs-number">0</span>, len, buffer);<br></code></pre></td></tr></table></figure><p>区域调用优点：</p><ol><li>只需要一个 JNI 调用，而不是两个，减少开销；</li><li>不需要固定实际数组或额外复制数据；</li><li>降低风险，不存在操作失败后忘记调用 Release 的风险。</li></ol><p>除此之外，JNI 还提供了针对于字符串的区域调用函数，<code>GetStringUTFRegion</code> 或 <code>GetStringRegion</code> 将字符数据复制到 <code>String</code> 对象之外。</p><h2 id="9-线程"><a href="#9-线程" class="headerlink" title="9. 线程"></a>9. 线程</h2><p>所有线程都是 Linux 线程，由内核调度。线程通常从受虚拟机管理的代码启动（使用 <code>Thread#start()</code> 方法），但也可以在 native 层创建，然后通过 JNI 函数附加到 JavaVM。在 C&#x2F;C++ 代码中例如使用 <code>pthread_create</code> 启动本地线程，然后调用 JNI 提供的 <code>AttachCurrentThread</code> 或 <code>AttachCurrentThreadAsDeamon</code> 函数，在附加之前，这个线程不会包含任何 <code>JNIEnv</code>，所以无法调用 <code>JNI</code>（<code>JNIEnv</code> 指针不能在多个线程中共享，只能分别附加，主线程默认已被附加）。</p><p>被附加成功的本地线程会构建 <code>java.lang.Thread</code> 对象并被添加到 Main ThreadGroup，从而使调试程序能够看到它。在已附加的线程上调用 <code>AttachCurrentThread</code> 属于空操作。</p><p>通过 JNI 附加的线程在退出之前必须调用 <code>DetachCurrentThread</code> 分离附加。如果直接对此进行编写代码会很麻烦，可以使用 <code>pthread_key_create</code> 定义在线程退出之前调用的析构函数，之后再调用 <code>DetachCurrentThread</code>。（将该 key 与 <code>pthread_setspecific</code> 配合使用，以将 <code>JNIEnv</code> 存储在线程本地存储中；这样一来，该 key 将作为参数传递到线程的析构函数中。）</p><h3 id="9-1-附加到本地线程"><a href="#9-1-附加到本地线程" class="headerlink" title="9.1 附加到本地线程"></a>9.1 附加到本地线程</h3><p>下面是一个附加到线程的示例，使用 <code>pthread_create</code> 创建一个线程，并在线程执行代码中附加：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">NativeHandler.<span class="hljs-built_in">testThread</span>();<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title">threadTest</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> </span>&#123;<br>  JNIEnv *env = <span class="hljs-literal">nullptr</span>;<br>  <br>  jint ret = gJavaVM-&gt;<span class="hljs-built_in">GetEnv</span>((<span class="hljs-type">void</span> **) &amp;env, JNI_VERSION_1_6);<br>  <span class="hljs-keyword">switch</span> (ret) &#123;<br>    <span class="hljs-keyword">case</span> JNI_OK:<br>      __android_log_print(ANDROID_LOG_DEBUG, TAG, <span class="hljs-string">&quot;获得了 JNIEnv.&quot;</span>);<br>      <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-keyword">case</span> JNI_EDETACHED:<br>      ret = gJavaVM-&gt;<span class="hljs-built_in">AttachCurrentThread</span>(&amp;env, <span class="hljs-literal">nullptr</span>);<br>      <span class="hljs-keyword">if</span> (ret == JNI_OK) &#123;<br>        __android_log_print(ANDROID_LOG_DEBUG, TAG, <span class="hljs-string">&quot;线程已附加. %ld&quot;</span>, (<span class="hljs-type">long</span>) <span class="hljs-built_in">pthread_getspecific</span>(gKey));<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        __android_log_print(ANDROID_LOG_ERROR, TAG, <span class="hljs-string">&quot;线程附加失败，code: %d.&quot;</span>, ret);<br>      &#125;<br>      <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-keyword">case</span> JNI_EVERSION:<br>      __android_log_print(ANDROID_LOG_DEBUG, TAG, <span class="hljs-string">&quot;错误 JNI_EVERSION.&quot;</span>);<br>      <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-keyword">default</span>:<br>      __android_log_print(ANDROID_LOG_ERROR, TAG, <span class="hljs-string">&quot;未知错误：%d&quot;</span>, ret);<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">threadDestroy</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> </span>&#123;<br>  JNIEnv *env = <span class="hljs-literal">nullptr</span>;<br>  jint ret = gJavaVM-&gt;<span class="hljs-built_in">GetEnv</span>((<span class="hljs-type">void</span> **) &amp;env, JNI_VERSION_1_6);<br><br>  <span class="hljs-keyword">if</span> (ret == JNI_OK) &#123;<br>    __android_log_print(ANDROID_LOG_DEBUG, TAG, <span class="hljs-string">&quot;线程分离.&quot;</span>);<br>    gJavaVM-&gt;<span class="hljs-built_in">DetachCurrentThread</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testThread</span><span class="hljs-params">(JNIEnv *env, jclass clazz)</span> </span>&#123;<br>  <br>  env-&gt;<span class="hljs-built_in">GetJavaVM</span>(&amp;gJavaVM);<br>  <br>  <span class="hljs-built_in">pthread_key_create</span>(&amp;gKey, &amp;threadDestroy);<br>  <br>  <span class="hljs-type">pthread_t</span> tid;<br>  <span class="hljs-type">int</span> ret = <span class="hljs-built_in">pthread_create</span>(&amp;tid, <span class="hljs-literal">nullptr</span>, &amp;threadTest, <span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>) &#123;<br>    __android_log_print(ANDROID_LOG_DEBUG, TAG, <span class="hljs-string">&quot;thread [%ld] create err&quot;</span>, tid);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <br>  <span class="hljs-built_in">pthread_join</span>(tid, <span class="hljs-literal">nullptr</span>);<br>  <br>  <span class="hljs-built_in">pthread_key_delete</span>(gKey);<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码，首先保存 <code>JavaVM</code>，然后启动线程，在线程中使用 <code>GetEnv</code> 函数尝试从线程获得 <code>JNIEnv</code>，返回值将有 3 种结果：</p><ol><li><code>JNI_OK</code>，说明此线程已附加，可直接使用获得的 <code>JNIEnv</code>；</li><li><code>JNI_EDETACHED</code>，说明此线程未附加，那么需要使用 <code>AttachCurrentThread</code> 进行附加；</li><li><code>JNI_EVERSION</code>，说明不支持指定的版本。</li></ol><p>在获得 <code>JNIEnv</code> 之后线程就执行完毕了，那么 <code>pthread_create</code> 中指定的线程析构函数 <code>threadDestroy</code> 将被回调，在这里确认线程已被附加后，使用 <code>DetachCurrentThread</code> 分离线程。</p><p><code>AttachCurrentThread</code> 的第 2 个参数一般可以指定为空，它是一个 <code>JavaVMAttachArgs</code> 结构指针，用于指定格外信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">JavaVMAttachArgs</span> &#123;<br>    jint        version;    <br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* name;       <br>    jobject     group;      <br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="10-JNI异常"><a href="#10-JNI异常" class="headerlink" title="10. JNI异常"></a>10. JNI异常</h2><p>当原生代码出现异常挂起时，大多数 JNI 函数无法被调用。通过 C&#x2F;C++ 代码可以检查到是否出现了异常（通过 <code>ExceptionCheck</code> 或者 <code>ExceptionOccurred</code> 的返回值）；或者直接清除异常。</p><p>在异常挂起时，只能调用如下 JNI 函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp">DeleteGlobalRef<br>DeleteLocalRef<br>DeleteWeakGlobalRef<br>ExceptionCheck<br>ExceptionClear<br>ExceptionDescribe<br>ExceptionOccurred<br>MonitorExit<br>PopLocalFrame<br>PushLocalFrame<br>Release&lt;PrimitiveType&gt;ArrayElements<br>ReleasePrimitiveArrayCritical<br>ReleaseStringChars<br>ReleaseStringCritical<br>ReleaseStringUTFChars<br></code></pre></td></tr></table></figure><p>许多 JNI 调用都会抛出异常，但通常可以使用一种更简单的方法来检查失败调用，例如 <code>NewString</code> 函数返回非空，则表示不需要检查异常。如果使用 <code>CallObjectMethod</code> 函数，则始终必须检查异常，如果系统抛出异常，那么函数返回值无效。</p><h3 id="10-1-检查异常"><a href="#10-1-检查异常" class="headerlink" title="10.1 检查异常"></a>10.1 检查异常</h3><p>使用 <code>ExceptionCheck</code> 函数可检查上一次代码调用是否出现了异常，如果出现异常，<code>ExceptionCheck</code> 将返回 <code>JNI_TRUE</code>，否则为 <code>JNI_FALSE</code>；或使用 <code>ExceptionOccurred</code> 函数，如果出现异常，它会返回一个 <code>jthrowable</code> 对象，否则为空。</p><p>通常使用 <code>ExceptionCheck</code> 函数，因为它不需要创建局部引用（<code>jthrowable</code>）。</p><p>在捕获到异常之后，使用 <code>ExceptionDescribe</code> 打印异常信息，如果调用 <code>ExceptionClear</code> 清除异常，那么异常将被忽略（不过在未处理的情况下盲目地忽略异常可能会出现问题）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkException</span><span class="hljs-params">(JNIEnv *env)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (env-&gt;<span class="hljs-built_in">ExceptionCheck</span>() == JNI_TRUE) &#123;<br>    env-&gt;<span class="hljs-built_in">ExceptionDescribe</span>();<br>    env-&gt;<span class="hljs-built_in">ExceptionClear</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-2-抛出异常"><a href="#10-2-抛出异常" class="headerlink" title="10.2 抛出异常"></a>10.2 抛出异常</h3><p>目前 Android 并不支持 C++ 异常。</p><p>JNI 提供了 <code>Throw</code> 和 <code>ThrowNew</code> 用来抛出 Java 异常，但不会在调用后就抛出异常，只是在当前线程中设置了异常指针。从本地代码返回到受虚拟机管理的代码后，会观察到这些异常指针并进行相应处理（抛出异常）。</p><p>JNI 没有提供直接操作 Java <code>Throwable</code> 对象本身的内置函数（直接创建对象或者获取异常信息）。</p><p>如果想要抛出指定异常，则需要自己找到 <code>Throwable</code> 类后，调用 <code>ThrowNew</code> 函数产生异常：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">env-&gt;<span class="hljs-built_in">ThrowNew</span>(env-&gt;<span class="hljs-built_in">FindClass</span>(<span class="hljs-string">&quot;java/lang/NullPointerException&quot;</span>), msg);<br><br>env-&gt;<span class="hljs-built_in">ThrowNew</span>(env-&gt;<span class="hljs-built_in">FindClass</span>(env, <span class="hljs-string">&quot;java/lang/RuntimeException&quot;</span>), msg);<br></code></pre></td></tr></table></figure><p>如果需要获取异常信息，那么需要查找 <code>Throwable#getMessage()</code> 的方法 ID 并调用。</p><h2 id="11-参考"><a href="#11-参考" class="headerlink" title="11. 参考"></a>11. 参考</h2><ul><li><p><a href="https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html">https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html</a></p></li><li><p><a href="https://developer.android.google.cn/training/articles/perf-jni">https://developer.android.google.cn/training/articles/perf-jni</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JNI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Handler机制</title>
    <link href="/2025/01/13/Handler%E6%9C%BA%E5%88%B6/"/>
    <url>/2025/01/13/Handler%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Java-Handler"><a href="#一、Java-Handler" class="headerlink" title="一、Java Handler"></a>一、Java Handler</h1><p>Handler 机制的设计<strong>主要</strong>是为了解决 Android 中 UI 只能在主线程更新的问题，从而保证 UI 的稳定性和正确性。但它本质上是一种通用的线程间通信机制，可以用于各种需要在不同线程之间传递消息和执行代码的场景。</p><p>例如：</p><ul><li><strong>后台任务的通知：</strong> 在子线程中执行一些耗时操作（例如网络请求、文件读写等）完成后，可以使用 Handler 将结果通知给主线程或其他线程。</li><li><strong>定时任务：</strong> 可以使用 Handler 的 <code>postDelayed()</code> 方法来执行定时任务。</li><li><strong>线程池的管理：</strong> 可以使用 Handler 来管理线程池中的线程，例如在线程池中的线程执行完成后，使用 Handler 将结果通知给主线程。</li></ul><h1 id="二、Java-Handler设计"><a href="#二、Java-Handler设计" class="headerlink" title="二、Java Handler设计"></a>二、Java Handler设计</h1><h3 id="1-Handler-机制的核心组成部分："><a href="#1-Handler-机制的核心组成部分：" class="headerlink" title="1. Handler 机制的核心组成部分："></a>1. Handler 机制的核心组成部分：</h3><p>在一个生产者-消费者模式中，通常会有三个角色</p><ul><li><strong>消息队列(single)</strong>  负责保存消息，提供存取消息的功能</li><li><strong>生产者(multiple)</strong>   负责生产消息，塞到共享的消息队列中</li><li><strong>消费者(multiple)</strong>   负责从共享消息队列中取出消息，执行消息对应的任务</li></ul><p><img src="/./img/Handler%E6%9C%BA%E5%88%B6_image/dac979a9f1294fa28ff31d71a66a5497tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-1736782242627-7.webp" alt="producer_consumer_queue.jpg"></p><p>在Handler机制的设计中</p><ul><li><strong>Handler：</strong> 负责发送和处理消息。（同时承担了消息的<strong>生产者</strong>和消息的<strong>执行者</strong>的角色），每个Handler都<strong>持有</strong>共享MessageQueue的引用，当调用Handler.sendMessage()方法发送消息时，Handler就会把消息保存到共享消息队列中</li><li><strong>Message：</strong> 消息的载体，包含需要传递的数据和需要执行的代码。</li><li><strong>MessageQueue：</strong> 消息队列，用于存储待处理的消息。</li><li><strong>Looper：</strong> 负责从 MessageQueue 中取出消息并分发给相应的 Handler 处理。（作为的消息的<strong>消费者</strong>,但是没有直接执行消息而是交由Handler去执行<strong>）严谨点是调用<code>Looper.loop()</code>所在的线程是消费者</strong>，因为Looper本质上只是封装对消息队列的操作，<code>Looper.loop()</code>方法负责取出共享消息队列里面的消息，然后交由Handler去执行</li></ul><p><img src="/./img/Handler%E6%9C%BA%E5%88%B6_image/5e60e67f3d2f41528daa3ead710df4c0tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-1736782242627-6.webp" alt="image_uml_design_pattern_behavioral_producer_consumer_handler.jpg"></p><h3 id="2-Handler-成员"><a href="#2-Handler-成员" class="headerlink" title="2. Handler 成员"></a>2. Handler 成员</h3><h4 id="2-1-Handler类"><a href="#2-1-Handler类" class="headerlink" title="2.1 Handler类"></a>2.1 Handler类</h4><p>Handler类是应用程序开发的入口，在消息队列机制中，扮演着<strong>生产者</strong>的角色，同时还肩负着<strong>消息执行者</strong>的重担，常用的方法有：</p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>sendMessage()系列</td><td>发送普通消息、延迟消息，最终调用<code>queue.enqueueMessage()</code>方法将消息存入消息队列</td></tr><tr><td>post()系列</td><td>提交普通&#x2F;延迟Runnable，随后封装成Message，调用<code>sendMessage()</code>存入消息队列</td></tr><tr><td>dispatchMessage(Message msg)</td><td>分发消息，优先执行<code>msg.callback</code>(也就是runnable)，其次<code>mCallback.handleMessage()</code>，最后<code>handleMessage()</code></td></tr></tbody></table><ol><li><p>Handler的源码中sendMessage()和post()相关方法最终都是调用到了queue.enqueueMessage()方法将消息存入消息队列</p></li><li><p>Handler的构造方法，默认的构造方法都是<code>同步的handler</code>,可以通过静态方法<code>createAsync</code>创建异步的Handler.<br><a href="https://developer.android.com/reference/android/os/Handler#createAsync(android.os.Looper)">https://developer.android.com/reference/android/os/Handler#createAsync(android.os.Looper)</a></p><p>异步Handler最主要的使用场景就是UI显示，UI显示相关的操作都要是异步消息，这样能够保证UI显示的高优先级。</p></li><li><p>构造Handler的时候需要传入Looper对象，通过Looper对象获取到消息队列 looper.mQueue;</p></li></ol><h4 id="2-2-Looper类"><a href="#2-2-Looper类" class="headerlink" title="2.2 Looper类"></a>2.2 Looper类</h4><p>Looper在消息队列机制中扮演<strong>消费者</strong>的角色，内部持有共享的消息队列，其本质是<strong>封装</strong>对消息队列的操作，常用的方法只有两个：</p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>prepare()</td><td>创建消息队列</td></tr><tr><td>loop()</td><td>遍历消息队列，不停地从消息队列中取消息，消息队列为空则等待</td></tr></tbody></table><ol><li><p>prepare()方法</p><p>初始化Looper，同时初始化Looper的时候初始化了消息队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepare</span><span class="hljs-params">(<span class="hljs-type">boolean</span> quitAllowed)</span> &#123;<br>    <span class="hljs-keyword">if</span> (sThreadLocal.get() != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Only one Looper may be created per thread&quot;</span>);<br>    &#125;<br>    sThreadLocal.set(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Looper</span>(quitAllowed));<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>loop()方法</p><p>从队列中取出消息，交由handler执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loop</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Looper</span> <span class="hljs-variable">me</span> <span class="hljs-operator">=</span> myLooper();<br>   <br>    <span class="hljs-comment">//...</span><br><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">//进入循环，每次调用loopOnce就处理一次消息，负责从 MessageQueue 中获取下一个 Message，执行其回调，并根据阈值检测是否是慢消息。</span><br>        <span class="hljs-keyword">if</span> (!loopOnce(me, ident, thresholdOverride)) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">loopOnce</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Looper me,</span><br><span class="hljs-params">    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> ident, <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> thresholdOverride)</span> &#123;<br>    <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> me.mQueue.next(); <span class="hljs-comment">// might block</span><br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//交由handler去处理msg</span><br>        msg.target.dispatchMessage(msg);<br>        <span class="hljs-keyword">if</span> (observer != <span class="hljs-literal">null</span>) &#123;<br>            observer.messageDispatched(token, msg);<br>        &#125;<br>        dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : <span class="hljs-number">0</span>;<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="2-3-MessageQueue类"><a href="#2-3-MessageQueue类" class="headerlink" title="2.3 MessageQueue类"></a>2.3 MessageQueue类</h4><p>实际的<strong>共享消息队列</strong>，提供保存和取出消息的功能，底层由链表实现，常用方法就一个：</p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>next()</td><td>获取消息，三种情况 <br />1. 有消息，且消息到期可以执行，返回消息 <br />2. 有消息，消息未到期，进入限时等待状态<br />3. 没有消息，进入无限期等待状态，直到被唤醒</td></tr></tbody></table><ol><li><p>MessageQueue有一个mQuitAllowed的属性，这个属性标记MessageQueue是否可以退出，退出的方法是调用<code>Looper.quit</code> 或者<code>Looper.quitSafely</code>,退出后会清除MessageQueue中的Message。<br><strong>主线程的 <code>MessageQueue</code> 不允许退出，以保证应用程序的正常运行。子线程的 <code>MessageQueue</code> 可以退出，以便在任务完成后释放资源。</strong></p></li><li><p>enqueueMessage方法</p><p>将message插入队列到队列合适的位置，并设置needWake。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">enqueueMessage</span><span class="hljs-params">(Message msg, <span class="hljs-type">long</span> when)</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br><span class="hljs-comment">//省略check msg是否在队列和 messageQueue退出的代码</span><br>        msg.markInUse();<br>        msg.when = when;<br>        <span class="hljs-type">Message</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> mMessages;<br>        <span class="hljs-type">boolean</span> needWake;<br>        <span class="hljs-comment">//插入到队列头，需要唤醒</span><br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> || when == <span class="hljs-number">0</span> || when &lt; p.when) &#123;<br>            <span class="hljs-comment">// New head, wake up the event queue if blocked.</span><br>            msg.next = p;<br>            mMessages = msg;<br>            needWake = mBlocked;<br>            <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span>) &#123;<br>                mLast = mMessages;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Message is to be inserted at tail or middle of queue. Usually we don&#x27;t have to</span><br>            <span class="hljs-comment">// wake up the event queue unless there is a barrier at the head of the queue and</span><br>            <span class="hljs-comment">// the message is the earliest asynchronous message in the queue.</span><br>            <span class="hljs-comment">//当msg插入到尾部或中间的时候，需要同时满足，1.正在阻塞 2.队列头有同步屏障 3.插入的是异步消息</span><br>            needWake = mBlocked &amp;&amp; p.target == <span class="hljs-literal">null</span> &amp;&amp; msg.isAsynchronous();<br><br>            <span class="hljs-comment">// For readability, we split this portion of the function into two blocks based on</span><br>            <span class="hljs-comment">// whether tail tracking is enabled. This has a minor implication for the case</span><br>            <span class="hljs-comment">// where tail tracking is disabled. See the comment below.</span><br>            <span class="hljs-comment">//根据是否尾部追踪区分代码（是否保存尾部的引用）</span><br>            <span class="hljs-keyword">if</span> (Flags.messageQueueTailTracking()) &#123;<br>                <span class="hljs-keyword">if</span> (when &gt;= mLast.when) &#123;<br>                    <span class="hljs-comment">//当前msg插入到尾部</span><br>                    needWake = needWake &amp;&amp; mAsyncMessageCount == <span class="hljs-number">0</span>;<br>                    msg.next = <span class="hljs-literal">null</span>;<br>                    mLast.next = msg;<br>                    mLast = msg;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// Inserted within the middle of the queue.</span><br>                    Message prev;<br>                    <span class="hljs-keyword">for</span> (;;) &#123;<br>                        prev = p;<br>                        p = p.next;<br>                        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> || when &lt; p.when) &#123;<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;<br>                            needWake = <span class="hljs-literal">false</span>; <span class="hljs-comment">//这里不太理解，如果发现队列中有异步消息就不唤醒，</span><br>                            <span class="hljs-comment">//原因是 已有的异步消息本身会触发队列的唤醒，所以额外的唤醒动作可以省略。</span><br>                            <span class="hljs-comment">//更深层的原因是消息队列的唤醒操作（nativeWake(mPtr)）是一个相对高成本的系统调用。</span><br>                            <span class="hljs-comment">//如果不必要地唤醒队列，会造成性能浪费。</span><br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span>) &#123;<br>                        <span class="hljs-comment">/* Inserting at tail of queue */</span><br>                        mLast = msg;<br>                    &#125;<br>                    msg.next = p; <span class="hljs-comment">// invariant: p == prev.next</span><br>                    prev.next = msg;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                Message prev;<br>                <span class="hljs-keyword">for</span> (;;) &#123;<br>                    prev = p;<br>                    p = p.next;<br>                    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> || when &lt; p.when) &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;<br>                        needWake = <span class="hljs-literal">false</span>;<br>                    &#125;<br>                &#125;<br>                msg.next = p; <span class="hljs-comment">// invariant: p == prev.next</span><br>                prev.next = msg;<br><br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                 * If this block is executing then we have a build without tail tracking -</span><br><span class="hljs-comment">                 * specifically: Flags.messageQueueTailTracking() == false. This is determined</span><br><span class="hljs-comment">                 * at build time so the flag won&#x27;t change on us during runtime.</span><br><span class="hljs-comment">                 *</span><br><span class="hljs-comment">                 * Since we don&#x27;t want to pepper the code with extra checks, we only check</span><br><span class="hljs-comment">                 * for tail tracking when we might use mLast. Otherwise, we continue to update</span><br><span class="hljs-comment">                 * mLast as the tail of the list.</span><br><span class="hljs-comment">                 *</span><br><span class="hljs-comment">                 * In this case however we are not maintaining mLast correctly. Since we never</span><br><span class="hljs-comment">                 * use it, this is fine. However, we run the risk of leaking a reference.</span><br><span class="hljs-comment">                 * So set mLast to null in this case to avoid any Message leaks. The other</span><br><span class="hljs-comment">                 * sites will never use the value so we are safe against null pointer derefs.</span><br><span class="hljs-comment">                 */</span><br>                mLast = <span class="hljs-literal">null</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (msg.isAsynchronous()) &#123;<br>             ++;<br>        &#125;<br><br>        <span class="hljs-comment">// We can assume mPtr != 0 because mQuitting is false.</span><br>        <span class="hljs-keyword">if</span> (needWake) &#123;<br>            nativeWake(mPtr);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>next() 方法</p><p>阻塞在nativePollOnce,否则的话，将当前最新的已经超时的同步msg或者异步msg返回给Looper，进一步的Looper交由Handler去处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java">Message <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// Return here if the message loop has already quit and been disposed.</span><br>    <span class="hljs-comment">// This can happen if the application tries to restart a looper after quit</span><br>    <span class="hljs-comment">// which is not supported.</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">ptr</span> <span class="hljs-operator">=</span> mPtr;<br>    <span class="hljs-keyword">if</span> (ptr == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">pendingIdleHandlerCount</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// -1 only during first iteration</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">nextPollTimeoutMillis</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">if</span> (nextPollTimeoutMillis != <span class="hljs-number">0</span>) &#123;<br>            Binder.flushPendingCommands();<br>        &#125;<br><span class="hljs-comment">//阻塞到native方法，等待native方法唤醒（java层队列或者native层队列有新的message插入）</span><br>        nativePollOnce(ptr, nextPollTimeoutMillis);<br><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-comment">// Try to retrieve the next message.  Return if found.</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> SystemClock.uptimeMillis();<br>            <span class="hljs-type">Message</span> <span class="hljs-variable">prevMsg</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> mMessages;<br>            <span class="hljs-keyword">if</span> (msg != <span class="hljs-literal">null</span> &amp;&amp; msg.target == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span><br>                <span class="hljs-keyword">do</span> &#123;<br>                    prevMsg = msg;<br>                    msg = msg.next;<br>                &#125; <span class="hljs-keyword">while</span> (msg != <span class="hljs-literal">null</span> &amp;&amp; !msg.isAsynchronous());<br>            &#125;<br>            <span class="hljs-keyword">if</span> (msg != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (now &lt; msg.when) &#123;<br>                    <span class="hljs-comment">//还没有到达超时，设置超时唤醒时间</span><br>                    <span class="hljs-comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span><br>                    nextPollTimeoutMillis = (<span class="hljs-type">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// Got a message.</span><br>                    mBlocked = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">if</span> (prevMsg != <span class="hljs-literal">null</span>) &#123;<br>                        prevMsg.next = msg.next;<br>                        <span class="hljs-keyword">if</span> (prevMsg.next == <span class="hljs-literal">null</span>) &#123;<br>                            mLast = prevMsg;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        mMessages = msg.next;<br>                        <span class="hljs-keyword">if</span> (msg.next == <span class="hljs-literal">null</span>) &#123;<br>                            mLast = <span class="hljs-literal">null</span>;<br>                        &#125;<br>                    &#125;<br>                    msg.next = <span class="hljs-literal">null</span>;<br>                    <span class="hljs-keyword">if</span> (DEBUG) Log.v(TAG, <span class="hljs-string">&quot;Returning message: &quot;</span> + msg);<br>                    msg.markInUse();<br>                    <span class="hljs-keyword">if</span> (msg.isAsynchronous()) &#123;<br>                        mAsyncMessageCount--;<br>                    &#125;<br>                    <span class="hljs-comment">//将message返回给Looper</span><br>                    <span class="hljs-keyword">return</span> msg;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// No more messages.</span><br>                nextPollTimeoutMillis = -<span class="hljs-number">1</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// Process the quit message now that all pending messages have been handled.</span><br>            <span class="hljs-keyword">if</span> (mQuitting) &#123;<br>                dispose();<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br><br><span class="hljs-comment">//...</span><br>            <br>            <span class="hljs-comment">//处理一些IdleHandler</span><br>        &#125;<br><br><span class="hljs-comment">//处理IdleHandler</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="2-4-Message类"><a href="#2-4-Message类" class="headerlink" title="2.4 Message类"></a>2.4 Message类</h4><p>消息的承载类，使用享元模式设计，根据API不同缓冲池大小也不同，API 4时缓冲池大小为10，常用方法：</p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>obtain()系列</td><td>获取一个消息实例</td></tr><tr><td>recycle()</td><td>回收消息实例</td></tr></tbody></table><p>获取Message的时候，使用Message.obtain()方法，在Looper.loop中将Message交给Handler进行处理之后，会调用recycle()回首Message实例到缓冲池中。</p><p>注意：由于在Looper.loop方法中，在调用handler.dispatchMessage之后就调用了recycle()将Message实例回收，因此要避免在handlerMessage的时候将msg对象抛到子线程去处理。</p><h1 id="三、Native-Handler设计"><a href="#三、Native-Handler设计" class="headerlink" title="三、Native Handler设计"></a>三、Native Handler设计</h1><p>Native Handler的设计是基于linux的<code>epoll</code>和<code>socketfd</code>机制。</p><h3 id="1-epoll"><a href="#1-epoll" class="headerlink" title="1.epoll"></a>1.epoll</h3><p><strong><code>epoll</code></strong> 全称 <code>eventpoll</code>，是 Linux 中的一种 <strong>I&#x2F;O 多路复用技术</strong>，除了 <strong><code>epoll</code></strong> 外，还有 <strong><code>select</code></strong> 和 <strong><code>poll</code></strong> 两种不同的实现方式，我们这只讨论 <strong><code>epoll</code></strong></p><p>要理解 <strong><code>epoll</code></strong> ，我们首先需要理解什么是 <strong><code>&quot;流&quot;</code></strong></p><p><strong>在 Linux 中，任何可以进行 I&#x2F;O 操作的对象都可以看做是流</strong>，一个 <code>文件</code>， <code>socket</code>， <code>pipe</code>，我们都可以把他们看作流</p><p>接着我们来讨论流的 I&#x2F;O 操作，通过调用 <strong><code>read()</code></strong> ，我们可以从流中<strong>读出数据</strong>；通过 <strong><code>write()</code></strong> ，我们可以往流 <strong>写入数据</strong></p><p>现在假定一个情形，<strong>我们需要从流中读数据，但是流中还没有数据</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> socketfd = socket();<br>connect(socketfd,serverAddr);<br><span class="hljs-type">int</span> n = send(socketfd,<span class="hljs-string">&#x27;在吗&#x27;</span>);<br>n = recv(socketfd); <span class="hljs-comment">//等待接受服务器端 发过来的信息</span><br>...<span class="hljs-comment">//处理服务器返回的数据</span><br></code></pre></td></tr></table></figure><p>一个典型的例子为，<strong>客户端要从 <code>socket</code> 中读数据，但是服务器还没有把数据传回来</strong>，这时候该怎么办？</p><ul><li><strong>阻塞：线程阻塞到 <code>recv()</code> 方法，直到读到数据后再继续向下执行</strong></li><li><strong>非阻塞：<code>recv()</code> 方法没读到数据立刻返回 -1 ，用户线程按照固定间隔轮询 <code>recv()</code> 方法，直到有数据返回</strong></li></ul><p>好，现在我们有了<strong>阻塞</strong>和<strong>非阻塞</strong>两种解决方案，接着我们同时发起100个网络请求，看看这两种方案各自会怎么处理</p><p>先说阻塞模式，<strong>在<code>阻塞模式</code>下，一个线程一次只能处理一个流的 I&#x2F;O 事件，想要同时处理多个流，只能使用<code>多线程 + 阻塞 I/O</code> 的方案</strong>。<strong>但是，每个 <code>socket</code> 对应一个线程会造成很大的资源占用，尤其是对于长连接来说，线程资源一直不会释放，如果后面陆续有很多连接的话，很快就会把机器的内存跑完</strong></p><p><strong>在<code>非阻塞模式</code>下，我们发现<code>单线程</code>可以同时处理多个流了，只要不停的把所有流从头到尾的问一遍是否有返回（返回值大于-1 ）就可以得知哪些流有数据，但这样的做法效率也不高，因为如果所有的流都没有数据，那么只会白白浪费 CPU</strong></p><p>发现问题了吗？只有<strong>阻塞</strong>和<strong>非阻塞</strong>这两种方案时，一旦有监听多个流事件的需求，用户程序只能选择，<strong>要么浪费线程资源（*<code>阻塞型 I/O</code>*）</strong>，<strong>要么浪费 CPU 资源（*<code>非阻塞型 I/O</code>*）</strong>，没有其他更高效的方案</p><p>并且在用户程序端这个问题是无解的，<strong>必须让内核创建某种机制，把这些流的监听事件接管过去</strong>，因为任何事件都必须通过内核读取转发，内核总是能在第一时间知晓事件发生</p><p><strong>这种能够让用户程序拥有同时监听多个流读写事件的机制，就被称为 I&#x2F;O 多路复用！</strong></p><p>然后我们来看 <strong><code>epoll</code></strong> 提供的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_create</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_ctl</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-type">int</span> op, <span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> epoll_event *event)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_wait</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-keyword">struct</span> epoll_event *events, <span class="hljs-type">int</span> maxevents, <span class="hljs-type">int</span> timeout)</span>;<br></code></pre></td></tr></table></figure><p>一共有三个函数，</p><ol><li><strong><code>epoll_create()</code></strong> 用于创建一个 <strong><code>epoll</code></strong> 池</li><li><strong><code>epoll_ctl()</code></strong> 用来控制需要监听的 <strong><code>fd</code></strong> 的增删改操作，最后一个参数 <strong><code>event</code></strong> 是告诉内核需要监听什么事件，比如上面的 <strong><code>socketfd </code></strong> 监听的就是 **<code>可读事件</code>**，一旦接收到服务器返回的数据，监听 <strong><code>socketfd</code></strong> 的对象将会收到回调通知，表示 <strong><code>socket</code></strong> 中有数据可以读了</li><li><strong><code>epoll_wait()</code></strong> 方法是使用户线程阻塞的方法，它的第二个参数 <strong><code>events</code></strong> 接受的是一个集合对象，如果有多个事件同时发生，**<code>events</code>** 可以从内核得到发生的事件的集合</li></ol><h3 id="2-socketfd"><a href="#2-socketfd" class="headerlink" title="2.socketfd"></a>2.socketfd</h3><p>理解了 <strong><code>epoll</code></strong> 后我们再来看 <strong><code>eventfd</code></strong> ，**<code>eventfd</code>** 是专门用来传递事件的 <strong><code>fd</code></strong> ，它提供的功能也非常简单：<strong>累计计数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> efd = eventfd();<br>write(efd, <span class="hljs-number">1</span>);<span class="hljs-comment">//写入数字1</span><br>write(efd, <span class="hljs-number">2</span>);<span class="hljs-comment">//再写入数字2</span><br><span class="hljs-type">int</span> res = read(efd);<br><span class="hljs-built_in">printf</span>(res);<span class="hljs-comment">//输出值为 3</span><br></code></pre></td></tr></table></figure><p>通过 <strong><code>write()</code></strong> 函数，我们可以向 <strong><code>eventfd</code></strong> 中写入一个 <strong><code>int</code></strong> 类型的值，只要没有发生 <strong><code>read()</code></strong> 事件，**<code> eventfd</code>** 中的值将会一直累加</p><p>而一旦我们调用 <strong><code>read()</code></strong> 函数将 <strong><code>eventfd</code></strong> 保存的值读了出来，在没有新的值加入之前，再次调用 <strong><code>read()</code></strong> 方法时会发生阻塞，直到有人重新向 <strong><code>eventfd</code></strong> 写入值</p><p><strong><code>eventfd</code> 实现的是计数的功能，只要 <code>eventfd</code> 计数不为 0 ，那么表示 <code>fd</code> 是可读的。结合 <code>epoll</code> 的特性，我们可以使用非常轻松的创建一个<code>生产者/消费者模型</code>，消费者大部分时候处于阻塞休眠状态，而一旦有请求入队，消费者就立马唤醒处理</strong></p><p>Handler 机制的底层逻辑就是 <strong><code>epoll</code></strong> + **<code>eventfd</code>**，好，有了 <strong><code>epoll</code></strong> 、 <strong><code>eventfd</code></strong> 基础，我们开始正式进入 Handler 的 Native 世界</p><h3 id="3-native-handler源码"><a href="#3-native-handler源码" class="headerlink" title="3.native handler源码"></a>3.native handler源码</h3><p>我们来重点关注 MessageQueue 类中的几个 <strong>jni</strong> 方法：**<code>nativeInit()</code><strong>、</strong><code>nativePollOnce()</code>** 和 **<code>nativeWake()</code>**，它们分别对应了 Native 消息队列中的 **<code>初始化消息队列</code>**、 <strong><code>消息的循环与阻塞</code></strong> 以及 <strong><code>消息的分送与唤醒</code></strong> 这三大环节</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">/frameworks/base/core/java/android/os/MessageQueue.java<br><span class="hljs-comment">//Android15源码中 MessageQueue.java的路径移动到了out/soong/.intermediates/frameworks/base/core/java/messagequeue-gen/gen/android/os/MessageQueue.java</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageQueue</span> &#123;<br><span class="hljs-comment">//初始化消息队列</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">nativeInit</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//消息的循环与阻塞</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nativePollOnce</span><span class="hljs-params">(<span class="hljs-type">long</span> ptr, <span class="hljs-type">int</span> timeoutMillis)</span>; <span class="hljs-comment">/*non-static for callbacks*/</span><br>    <span class="hljs-comment">//消息的分送与唤醒</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nativeWake</span><span class="hljs-params">(<span class="hljs-type">long</span> ptr)</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-1-消息队列的初始化"><a href="#3-1-消息队列的初始化" class="headerlink" title="3.1 消息队列的初始化"></a>3.1 消息队列的初始化</h4><p>先来看第一步，消息队列的初始化流程</p><p><strong>Java MessageQueue 构造函数中会调用 <code>nativeInit()</code> 方法，同步在 Native 层也会创建一个消息队列 NativeMessageQueue 对象，用于保存 Native 开发者发送的消息</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">/frameworks/base/core/java/android/os/MessageQueue.java<br><span class="hljs-title function_">MessageQueue</span><span class="hljs-params">(<span class="hljs-type">boolean</span> quitAllowed)</span> &#123;<br>    mQuitAllowed = quitAllowed;<br>    mPtr = nativeInit();<br>&#125;<br></code></pre></td></tr></table></figure><p>在创建 NativeMessageQueue 对象时又会触发创建 Looper 对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp">/frameworks/base/core/jni/android_os_MessageQueue.cpp<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">android_os_MessageQueue</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">android_os_MessageQueue_nativeInit</span><span class="hljs-params">()</span> </span>&#123;<br>        NativeMessageQueue* nativeMessageQueue = <span class="hljs-keyword">new</span> <span class="hljs-built_in">NativeMessageQueue</span>();<br>    &#125;<br>    <br>    <span class="hljs-built_in">NativeMessageQueue</span>() &#123;<br>        mLooper = Looper::<span class="hljs-built_in">getForThread</span>();<br>        <span class="hljs-keyword">if</span> (mLooper == <span class="hljs-literal">NULL</span>) &#123;<br>            mLooper = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Looper</span>(<span class="hljs-literal">false</span>);<br>            Looper::<span class="hljs-built_in">setForThread</span>(mLooper);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>这里创建 Looper 对象的处理逻辑和 Java 一样，先去线程局部存储区获取 Looper 对象，如果为空，创建一个新的 Looper 对象并保存到线程局部存储区</strong></p><p>我们继续，接着来看 <strong>Native Looper 初始化流程</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp">/system/core/libutils/Looper.cpp<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">looper</span> &#123;<br><br>    Looper::<span class="hljs-built_in">Looper</span>() &#123;<br>        <span class="hljs-comment">//创建了eventfd，用来监听 MessageQueue 是否有新消息加入</span><br>        <span class="hljs-type">int</span> mWakeEventFd = <span class="hljs-built_in">eventfd</span>();<br>        <span class="hljs-built_in">rebuildEpollLocked</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rebuildEpollLocked</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-type">int</span> mEpollFd = <span class="hljs-built_in">epoll_create</span>();<span class="hljs-comment">//哎，这儿非常重要，在 Looper 初始化时创建了 epoll 对象</span><br>        <span class="hljs-built_in">epoll_ctl</span>(mEpollFd, EPOLL_CTL_ADD, mWakeEventFd, &amp; eventItem);<span class="hljs-comment">//把用于唤醒消息队列的eventfd 添加到 epoll 池</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>关键的地方来了！</strong></p><p><strong>Looper 的构造函数首先创建了 <code>eventfd</code> 类型的 <code>fd</code> ：<code>mWakeEventFd</code>，它的作用就是用来监听 MessageQueue 是否有新消息加入，这个对象非常重要，一定要记住它！</strong></p><p><strong>随后调用的 <code>rebuildEpollLocked()</code> 方法中，又创建了 <code>epoll</code> 对象：<code>mEpollFd</code>，并将用来监听消息队列的 <code>mWakeEventFd</code> 添加到 <code>epoll</code> 池</strong></p><p>这两步执行完成以后，<strong>任一生产者向 <code>mWakeEventFd</code> 写入值时，作为消费者，APP 进程的 <code>main</code> 线程都将会被唤醒</strong></p><p>好了，Handler 两大核心对象 <strong><code>mEpollFd</code></strong> 和 <strong><code>mWakeEventFd</code></strong> 创建成功，我们来总结一下消息队列的初始化流程：</p><ol><li><strong>Java 层初始化消息队列时，同步调用 <code>nativeInit()</code> 方法，在 native 层创建了一个 NativeMessageQueue 对象</strong></li><li><strong>Native 层消息队列被创建的同时，也会创建一个 Native Looper ，它用于处理三件事： native 注册的<code>自定义 Fd</code> 引起的事件消息、消息队列被唤醒和超时以及分发 Native 消息队列中的到期消息</strong></li><li><strong>在创建 Native Looper 的过程中，调用 <code>eventfd()</code> 生成<code> mWakeEventFd</code>，它是后续用于唤醒消息队列的核心</strong></li><li><strong>初始化 Native Looper 的最后一步调用了 <code>rebuildEpollLocked()</code> 方法，在其中调用 <code>epoll_create()</code> 初始化了一个 <code>epoll</code> 实例 <code>mEpollFd</code> ，然后使用 <code>epoll_ctl()</code> 方法将 <code>mEpollFd</code> 注册到 <code>epoll</code> 池</strong></li></ol><p><strong>至此，Native 层的消息队列初始化完成</strong></p><h4 id="3-2-消息的循环与阻塞"><a href="#3-2-消息的循环与阻塞" class="headerlink" title="3.2 消息的循环与阻塞"></a>3.2 消息的循环与阻塞</h4><p>消息队列创建完以后，整个线程就会阻塞到 <strong><code>Looper#loop()</code></strong> 方法中，在 Java 层的的调用链大致是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Looper#loop()<br>    -&gt; MessageQueue#next()<br>        -&gt; MessageQueue#nativePollOnce()<br></code></pre></td></tr></table></figure><p><strong>最后一步调用的 <code>nativePollOnce()</code> 又是一个 jni 方法，我们接着往下跟，看看 Native 中做了些什么</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp">/frameworks/base/core/jni/android_os_MessageQueue.cpp<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">android_os_MessageQueue</span> &#123;<br><br>    <span class="hljs-comment">//jni方法，转到 NativeMessageQueue#pollOnce()</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">android_os_MessageQueue_nativePollOnce</span><span class="hljs-params">()</span></span>&#123;<br>        nativeMessageQueue-&gt;<span class="hljs-built_in">pollOnce</span>(env, obj, timeoutMillis);<br>    &#125;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">NativeMessageQueue</span> : MessageQueue &#123;<br>        <span class="hljs-comment">//转到 Looper#pollOnce() 方法</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pollOnce</span><span class="hljs-params">()</span></span>&#123;<br>            mLooper-&gt;<span class="hljs-built_in">pollOnce</span>(timeoutMillis);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>可以看到 NativeMessageQueue 中什么都没做，只是把 <code>nativePollOnce()</code> 方法请求转发给了 Looper</strong></p><p><strong>主要的逻辑都在 Looper 中，我们从 <code>Looper#pollOnce()</code> 方法接着往下看</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//system/core/libutils/Looper.cpp</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">looper</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pollOnce</span><span class="hljs-params">(<span class="hljs-type">int</span> timeoutMillis)</span></span>&#123;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">if</span> (result != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> result;<br>            &#125;<br>            result = <span class="hljs-built_in">pollInner</span>(timeoutMillis);<span class="hljs-comment">//超时</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pollInner</span><span class="hljs-params">(<span class="hljs-type">int</span> timeoutMillis)</span></span>&#123;<br>        <span class="hljs-type">int</span> eventCount = <span class="hljs-built_in">epoll_wait</span>(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);<span class="hljs-comment">//调用 epoll_wait() 等待事件的产生</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>看到了吗？ <code>pollOnce()</code> 方法中会不停的轮询检查 <code>pollInner()</code> 的返回值，不等于 0 就返回给上层，这里的 <code>result</code> 类型是在 <code>Looper.h</code> 文件中声明的枚举类，一共有4种结果：</strong></p><ul><li>-1 表示在超时时间到期之前使用 <strong><code>wake()</code></strong> 唤醒了轮询，通常是有需要立刻执行的新消息加入了队列</li><li>-2 表示多个事件同时发生，有可能是新消息加入，也有可能是监听的 <strong><code>自定义 fd</code></strong> 发生了 I&#x2F;O 事件</li><li>-3 表示设定的超时时间到期了</li><li>-4 表示错误，不知道哪里会用到</li></ul><p><strong>而如果消息队列中没消息，或者设定的超时时间没到期，再或者用户<code>自定义 fd</code> 没有事件发生，都会导致线程最终会阻塞到 <code>pollInner()</code> 方法中， <code>pollInner()</code> 中则是使用了 <code>epoll_wait()</code> 方法等待事件的产生</strong></p><p><strong>总结一下，消息队列在初始化成功以后，Java 层的 <code>Looper#loop()</code> 会开始无限轮询，不停的获取下一条消息。如果消息队列为空，调用 <code>epoll_wait</code> 使线程进入到阻塞态，让出 CPU 调度</strong></p><p>从 Java 到 Native 整个调用流程大致是这样的：</p><figure class="highlight leaf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs leaf">Looper<span class="hljs-punctuation">#</span><span class="hljs-keyword">loop</span><span class="hljs-params">()</span><br>    -&gt; MessageQueue<span class="hljs-punctuation">#</span><span class="hljs-keyword">next</span><span class="hljs-params">()</span><br>        -&gt; MessageQueue<span class="hljs-punctuation">#</span><span class="hljs-keyword">nativePollOnce</span><span class="hljs-params">()</span><br>            -&gt; NativeMessageQueue<span class="hljs-punctuation">#</span><span class="hljs-keyword">pollOnce</span><span class="hljs-params">()</span> //注意，进入 Native 层<br>                -&gt; Looper<span class="hljs-punctuation">#</span><span class="hljs-keyword">pollOnce</span><span class="hljs-params">()</span><br>                    -&gt; Looper<span class="hljs-punctuation">#</span><span class="hljs-keyword">pollInner</span><span class="hljs-params">()</span><br>                        -&gt; epoll_wait()<br></code></pre></td></tr></table></figure><h4 id="3-3-消息的发送-唤醒机制"><a href="#3-3-消息的发送-唤醒机制" class="headerlink" title="3.3 消息的发送&#x2F;唤醒机制"></a>3.3 消息的发送&#x2F;唤醒机制</h4><p>好，现在的消息队列里面是空的，经过上一小节的分析，我们发现用户线程阻塞到了 native 层的 <strong><code>Looper#pollInner()</code></strong> 方法调用中，我们来向消息队列发送一条消息唤醒它</p><p>前面我们说了，Java 和 Native 都各自维护了一套消息队列，所以他们发送消息的入口也不一样</p><p><strong>Java 开发使用 <code>Handler#sendMessage() / post()</code>，C&#x2F;C++ 开发使用 <code>Looper#sendMessage()</code></strong></p><p>我们先来看 Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">/frameworks/base/core/java/android/os/Handler.java<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Handler</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">enqueueMessage</span><span class="hljs-params">(MessageQueue queue, Message msg, <span class="hljs-type">long</span> uptimeMillis)</span> &#123;<br>        msg.target = <span class="hljs-built_in">this</span>;<br>        <span class="hljs-comment">//消息入队列</span><br>        <span class="hljs-keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);<br>    &#125;<br>&#125;<br><br>/frameworks/base/core/java/android/os/MessageQueue.java<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageQueue</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">enqueueMessage</span><span class="hljs-params">(Message msg, <span class="hljs-type">long</span> when)</span> &#123;<br>        <span class="hljs-comment">//...按照到期时间将消息插入消息队列</span><br>        <span class="hljs-keyword">if</span> (needWake) &#123;<br>            nativeWake(mPtr);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>在使用 Handler 发送消息时，不管调用的是 <code>sendMessage</code> 还是 <code>post</code>，最后都是调用到 <code>MessageQueue#enqueueMessage()</code> 方法将消息入列，入列的顺序是按照执行时间先后排序</strong></p><p><strong>如果我们发送的消息需要马上被执行，那么将 <code>needWake</code> 变量置为 <code>true</code>，接着使用 <code>nativeWake()</code> 唤醒线程</strong></p><blockquote><p><strong><code>nativeWake()</code> 方法也是 jni 调用，请求经过层层转发，最终会调用到 Native Looper 中的 <code>wake()</code> 方法，在此过程中的调用链比较清晰而且非常简单，这里就不展示了</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Handler#post()/sendMessage()<br>-&gt;MessageQueue#enqueueMessage()<br>-&gt;MessageQueue#nativeWake()<br>-&gt;nativeMessageQueue#wake() -----进入<span class="hljs-keyword">native</span>层<br>    -&gt;Looper#wake()<br>    -&gt;write(mWakeEventFd.get(), &amp;inc, sizeof(uint64_t)));<br><span class="hljs-comment">//向eventfd写入1,也就是计数增一，然后是epoll监听到eventfd写入就会收到通知。</span><br></code></pre></td></tr></table></figure></blockquote><p>Java 发送消息的方式聊完了，然后我们看 Native 层如何发送消息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">/system/core/libutils/Looper.cpp<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">looper</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Looper::sendMessageAtTime</span><span class="hljs-params">(uptime, handler,message)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> messageCount = mMessageEnvelopes.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">while</span> (i &lt; messageCount &amp;&amp; uptime &gt;= mMessageEnvelopes.<span class="hljs-built_in">itemAt</span>(i).uptime) &#123;<br>            i += <span class="hljs-number">1</span>;<br>        &#125;<br>        mMessageEnvelopes.<span class="hljs-built_in">insertAt</span>(<span class="hljs-built_in">messageEnvelope</span>(uptime, handler, message), i, <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// Wake the poll loop only when we enqueue a new message at the head.</span><br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">wake</span>();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Native 层通过 <code>sendMessageAtTime()</code> 方法向消息队列发送消息，添加消息的处理逻辑和 Java 处理逻辑是类似的，唯一有区别的一点是 Java 消息队列使用的链表结构，而 Native 层使用的是集合</strong></p><p><strong>按照时间的先后顺序添加到 <code>mMessageEnvelopes</code> 集合中，执行时间离得最近的消息被放在前面，如果发现需要唤醒线程，则调用 <code>wake()</code> 方法</strong></p><p>我们发现，<strong>当需要唤醒线程时，Java 和 Native 都会执行到 <code>Looper#wake()</code> 方法</strong></p><p>之前我们说**Handler 机制的底层逻辑就是 <code>epoll</code> + <code>eventfd</code>**，读者朋友不妨大胆猜一下，这里的线程是怎么被唤醒的？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">/system/core/libutils/Looper.cpp<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">looper</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Looper::wake</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> inc = <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">write</span>(mWakeEventFd, &amp;inc);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>答案非常简单，**<code>write()</code> 一行方法调用，向 <code>mWakeEventFd</code> 写入了一个 1（*提醒一下，<code>mWakeEventFd</code> 的类型是 <code>eventfd</code>* ）**</p><p><strong><code>eventfd</code></strong> 被写入值后，状态会从 <strong><code>不可读</code></strong> 变成 **<code>可读</code>**，而 <strong><code>epoll</code></strong> 监听到 <strong><code>fd</code></strong> 状态发生变化后，将事件从内核返回给 <strong><code>epoll_wait()</code></strong> 调用，线程的阻塞态将会被取消，继续向下执行</p><p>好，我们来总结一下消息的发送与唤醒中几个关键的步骤：</p><ol><li><strong>Java 层的 Handler 发送消息，会调用到消息队列的 <code>enqueueMessage()</code> 方法，如果消息需要马上执行，那么调用 <code>nativeWake()</code> 执行唤醒，由 Native 层的 <code>Looper#wake()</code> 响应最终的唤醒请求</strong></li><li><strong>Native 层通过 <code>Looper#sentMessageAtTime()</code> 来发送消息，处理逻辑与 Java 类似，如果需要唤醒线程，调用 <code>Looper#wake()</code></strong></li><li><strong><code>Looper#wake()</code> 唤醒方法中，调用 <code>write()</code> 方法向 <code>mWakeEventFd</code> 写入 1</strong></li><li><strong>初始化队列时为 <code>mWakeEventFd</code> 注册了 <code>epoll</code> 监听，所以一旦有来自于 <code>mWakeEventFd</code> 的新内容， <code>epoll_wait()</code> 阻塞调用就会返回，这里就已经起到了唤醒队列的作用</strong></li></ol><p>消息的发送与唤醒的流程基本上结束了，接下来是 Handler 机制的重头戏：<strong>线程唤醒后的消息分发处理</strong></p><h4 id="3-4-唤醒后消息的分发处理"><a href="#3-4-唤醒后消息的分发处理" class="headerlink" title="3.4 唤醒后消息的分发处理"></a>3.4 唤醒后消息的分发处理</h4><p>线程在没有消息需要处理时会阻塞在 <strong><code>Looper#pollInner()</code></strong> 方法调用，唤醒同样也是在 <strong><code>pollInner()</code></strong> 方法中执行</p><p><strong>线程醒来以后，先判断自己为什么醒过来，再根据唤醒类型执行不同的逻辑</strong></p><blockquote><p><strong><code>pollInner()</code> 方法稍微有点长，关键步骤我作了标记，我们一点点来捋</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp">/system/core/libutils/Looper.cpp<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">looper</span> &#123;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pollInner</span><span class="hljs-params">(<span class="hljs-type">int</span> timeoutMillis)</span></span>&#123;<br>        <span class="hljs-type">int</span> result = POLL_WAKE;<br>        <span class="hljs-comment">// step 1，epoll_wait 方法返回</span><br>        <span class="hljs-type">int</span> eventCount = <span class="hljs-built_in">epoll_wait</span>(mEpollFd, eventItems, timeoutMillis); <br>        <span class="hljs-keyword">if</span> (eventCount == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 事件数量为0表示，达到设定的超时时间</span><br>            result = POLL_TIMEOUT;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; eventCount; i++) &#123;<br>            <span class="hljs-keyword">if</span> (eventItems[i] == mWakeEventFd) &#123;<br>                <span class="hljs-comment">// step 2 ，清空 eventfd，使之重新变为可读监听的 fd</span><br>                <span class="hljs-built_in">awoken</span>();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// step 3 ，保存自定义fd触发的事件集合</span><br>                mResponses.<span class="hljs-built_in">push</span>(eventItems[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// step 4 ，执行 native 消息分发</span><br>        <span class="hljs-keyword">while</span> (mMessageEnvelopes.<span class="hljs-built_in">size</span>() != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (messageEnvelope.uptime &lt;= now) &#123; <span class="hljs-comment">// 检查消息是否到期</span><br>                messageEnvelope.handler-&gt;<span class="hljs-built_in">handleMessage</span>(message);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// step 5 ，执行 自定义 fd 回调</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; mResponses.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            response.request.callback-&gt;<span class="hljs-built_in">handleEvent</span>(fd, events, data);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">awoken</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">read</span>(mWakeEventFd) ;<span class="hljs-comment">// 重新变成可读事件</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>step 1 ：</strong> <strong><code>epoll_wait</code></strong> 方法返回说明有事件发生，返回值 <strong><code>eventCount</code></strong> 是发生事件的数量。如果为0，表示达到设定的超时时间，下面的判断逻辑都不会走，不为0，那么我们开始遍历内核返回的事件集合 **<code>eventItems</code>**，根据类型执行不同的逻辑</p><p><strong>step 2 ：</strong> 如果事件类型是消息队列的 <strong><code>eventfd</code></strong> ，说明有人向消息队列提交了需要马上执行的消息，我们只需把消息队列的 <strong><code>eventfd</code></strong> 数据读出来，使他重新变成可以触发 <strong><code>可读事件</code></strong> 的 **<code>fd</code>**，然后等待方法结束就行了</p><p><strong>step 3 ：</strong> 事件不是消息队列的 <strong><code>eventfd</code></strong> ，说明有其他地方注册了监听 **<code>fd</code>**，那么，我们将发生的事件保存到 <strong><code>mResponses</code></strong> 集合中，待会需要对这个事件做出响应，通知注册对象</p><p><strong>step 4 ：</strong> 遍历 Native 的消息集合 **<code>mMessageEnvelopes</code>**，检查每个消息的到期时间，如果消息到期了，交给 handler 执行分发，分发逻辑参考 Java Handler</p><p><strong>step 5 ：</strong> 遍历 <strong><code>mResponses</code></strong> 集合，把其他地方注册的 <strong><code>自定义 fd</code></strong> 消费掉，响应它们的回调方法</p><p>唤醒以后执行的步骤稍微有点多哈，我们把关键流程总结一下：</p><p><strong>用户线程被唤醒后，优先执行 Native 层的消息分发，紧接着，回调通知<code>自定义 fd</code> 发生的事件（*如果有的话*），然后 <code>pollInner()</code> 方法结束，返回到 Java 层 <code>Looper#loop()</code> 方法。在 Looper 中最后执行到 Java 层的消息分发，只有当 Java Handler 执行完消息分发，一次 <code>loop()</code> 循环才算是完成</strong></p><p><strong>再之后， <code>Looper#loop()</code> 会再一次进入循环，继续调用 <code>next()</code> 方法获取消息、阻塞到 <code>pollInner()</code> 、从 <code>pollInner()</code> 唤醒执行分发，执行结束接着进入下一次循环，无尽的轮回</strong></p><p><strong><code>main</code> 线程的一生都将重复这一流程，直到 APP 进程结束运行..</strong></p><p><img src="/./img/Handler%E6%9C%BA%E5%88%B6_image/image-20250113225334608-1736782242627-8.png" alt="Handler机制消息循环"></p><h1 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a>四、其他</h1><h4 id="1-异步消息的优先级体现在哪里？"><a href="#1-异步消息的优先级体现在哪里？" class="headerlink" title="1. 异步消息的优先级体现在哪里？"></a>1. 异步消息的优先级体现在哪里？</h4><p>异步消息在插入队列的时候并没有特殊的优先级，也是按照when属性插入到对应的位置，异步消息的优先级体现在队头插入了同步消息屏障的场景下，在遍历队列的时候会跳过所有的同步消息而优先处理异步消息。</p><h4 id="2-异步消息的flag何时set？"><a href="#2-异步消息的flag何时set？" class="headerlink" title="2. 异步消息的flag何时set？"></a>2. 异步消息的flag何时set？</h4><p>异步消息的flag是在调用MessageQueue.equeue之前，根据当前Handler是否是异步Handler来进行set的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//   /frameworks/base/core/java/android/os/Handler.java</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">enqueueMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> MessageQueue queue, <span class="hljs-meta">@NonNull</span> Message msg,</span><br><span class="hljs-params">        <span class="hljs-type">long</span> uptimeMillis)</span> &#123;<br>    msg.target = <span class="hljs-built_in">this</span>;<br>    msg.workSourceUid = ThreadLocalWorkSource.getUid();<br><br>    <span class="hljs-keyword">if</span> (mAsynchronous) &#123;<br>        <span class="hljs-comment">//这里设置了msg的异步标志</span><br>        msg.setAsynchronous(<span class="hljs-literal">true</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-异步消息和同步屏障的使用场景"><a href="#3-异步消息和同步屏障的使用场景" class="headerlink" title="3. 异步消息和同步屏障的使用场景"></a>3. 异步消息和同步屏障的使用场景</h4><p>异步消息和同步屏障的使用场景是在UI绘制阶段，将UI绘制相关的任务封装为异步消息，然后在合适的时机添加同步屏障，之后就会优先处理这些异步消息（保证UI绘制的流畅性），在UI绘制完成之后，移除同步屏障。</p><p>根据以上场景，<strong>在普通应用的开发中，用不到这种异步消息的机制，而且同步屏障相关的方法也是私有的，并没有暴露给上层开发者</strong>。</p><p>尝试通过反射调用添加同步屏障方法（MessageQueue#postSyncBarrier），如果将同步屏障加入到Main线程的消息队列中，就会导致主线程只处理UI绘制任务和自定义的异步消息，而不会处理任何同步消息（<strong>点击相关事件也是同步消息，点击事件不被处理就会导致app  ANR）。</strong></p><h4 id="4-native-Handler中的自定义fd"><a href="#4-native-Handler中的自定义fd" class="headerlink" title="4. native Handler中的自定义fd"></a>4. native Handler中的自定义fd</h4><p>native Handler中有两个方法发送消息</p><p>Looper#sendMessage :这个方法会将消息插入到native维护的一个队列中</p><p>Looper#addfd :这个方法是将自定义的fd加入到epoll中，<strong>通过向这个fd调用write系统调用，epoll从中脱离阻塞状态，进而执行。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Looper::addFd</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> ident, <span class="hljs-type">int</span> events, Looper_callbackFunc callback, <span class="hljs-type">void</span>* data)</span> </span>&#123;<br>    sp&lt;SimpleLooperCallback&gt; looperCallback;<br>    <span class="hljs-keyword">if</span> (callback) &#123;<br>        looperCallback = sp&lt;SimpleLooperCallback&gt;::<span class="hljs-built_in">make</span>(callback);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">addFd</span>(fd, ident, events, looperCallback, data);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-当前的native-Handler和NDK-ALooper"><a href="#5-当前的native-Handler和NDK-ALooper" class="headerlink" title="5. 当前的native Handler和NDK ALooper"></a>5. 当前的native Handler和NDK ALooper</h4><p><code>Looper.cpp</code> 是 Java 层 <code>Looper</code> 的 native 实现，用于支持应用层的消息循环。</p><p><code>ALooper</code> 是 Native 层的消息循环实现，用于系统服务和底层模块。</p><p>两者共享一些底层机制（如 epoll 和 pipe），但服务的目标和使用场景不同。</p><p>参考文章：</p><p><a href="https://juejin.cn/post/7084544971713282056#heading-15">java Hadnler机制</a></p><p><a href="https://github.com/yibaoshan/yibaoshan/blob/963bdc312c9b69abdbb09b9026f194c2c1f08105/application-android-blog-sample/src/main/java/com/android/blog/android/components/handler/Android%E7%BB%84%E4%BB%B6%E7%B3%BB%E5%88%97%EF%BC%9A%E5%86%8D%E8%B0%88Handler%E6%9C%BA%E5%88%B6%EF%BC%88Native%E7%AF%87%EF%BC%89.md">native Handler机制</a></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Handler</tag>
      
      <tag>Message</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Parcel和Parcelable</title>
    <link href="/2025/01/05/Parcel%E5%92%8CParcelable/"/>
    <url>/2025/01/05/Parcel%E5%92%8CParcelable/</url>
    
    <content type="html"><![CDATA[<p>参考：<a href="http://quibbler.cn/?thread-688.htm">http://quibbler.cn/?thread-688.htm</a></p><p><a href="http://quibbler.cn/?thread-531.htm">http://quibbler.cn/?thread-531.htm</a></p><p><a href="https://developer.android.com/reference/android/os/Parcel#summary">https://developer.android.com/reference/android/os/Parcel#summary</a></p><h2 id="一-Parcel类"><a href="#一-Parcel类" class="headerlink" title="一.Parcel类"></a>一.Parcel类</h2><p>根据官方文档，可知：Parcel是一个跨进程传输的容器，通过接口读写数据。</p><p>Container for a message (data and object references) that can be sent through an IBinder. A Parcel can contain both flattened data that will be unflattened on the other side of the IPC (using the various methods here for writing specific types, or the general <code>Parcelable</code> interface), and references to live <code>IBinder</code> objects that will result in the other side receiving a proxy IBinder connected with the original IBinder in the Parcel.</p><h3 id="1-获取Parcel实例"><a href="#1-获取Parcel实例" class="headerlink" title="1.获取Parcel实例"></a>1.获取Parcel实例</h3><p> <a href="https://developer.android.google.cn/reference/android/os/Parcel?hl=en">Parcel</a>实例只能通过该类提供的静态方法obtain()获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Parcel</span> <span class="hljs-variable">parcel</span> <span class="hljs-operator">=</span> Parcel.obtain();<br></code></pre></td></tr></table></figure><p>​    obtain()静态方法实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Retrieve a new Parcel object from the pool.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Parcel <span class="hljs-title function_">obtain</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> Parcel[] pool = sOwnedPool;<br>    <span class="hljs-keyword">synchronized</span> (pool) &#123;<br>        Parcel p;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;POOL_SIZE; i++) &#123;<br>            p = pool[i];<br>            <span class="hljs-comment">//从复用对象池中取出一个可用非空实例返回，</span><br>            <span class="hljs-comment">//并将当前池子中的位置设置为null，以便后面recycle()回收用</span><br>            <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">null</span>) &#123;<br>                pool[i] = <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">if</span> (DEBUG_RECYCLE) &#123;<br>                    p.mStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();<br>                &#125;<br>                p.mReadWriteHelper = ReadWriteHelper.DEFAULT;<br>                <span class="hljs-keyword">return</span> p;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//如果池子中没有可用的对象，那么直接创建新的实例返回 </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parcel</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">//构造函数是私有的</span><br><span class="hljs-keyword">private</span> <span class="hljs-title function_">Parcel</span><span class="hljs-params">(<span class="hljs-type">long</span> nativePtr)</span> &#123;<br>    <span class="hljs-keyword">if</span> (DEBUG_RECYCLE) &#123;<br>        mStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();<br>    &#125;<br>    <span class="hljs-comment">//Log.i(TAG, &quot;Initializing obj=0x&quot; + Integer.toHexString(obj), mStack);</span><br>    init(nativePtr);<br>&#125;<br></code></pre></td></tr></table></figure><p>在 Android 的 <code>Parcel</code> 类中，<code>sOwnedPool</code> 是一个对象池（object pool），用于管理 <code>Parcel</code> 对象的重用。<strong>对象池</strong>是 <strong>进程私有的</strong>，而不是全局唯一的。这意味着每个进程都有自己独立的 <code>Parcel</code> 池。通过对象池的方式，可以减少频繁创建和销毁 <code>Parcel</code> 对象的开销，降低内存分配的成本。</p><h5 id="回收Parcel"><a href="#回收Parcel" class="headerlink" title="回收Parcel"></a>回收Parcel</h5><p>​    获取到的<a href="https://developer.android.google.cn/reference/android/os/Parcel?hl=en">Parcel</a>对象在使用完之后，一定要调用recycle()方法将该对象回收尽可能复用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Parcel</span> <span class="hljs-variable">parcel</span> <span class="hljs-operator">=</span> Parcel.obtain();<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">//TODO</span><br>&#125;<span class="hljs-keyword">finally</span> &#123;<br>    parcel.recycle();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Put a Parcel object back into the pool.  You must not touch</span><br><span class="hljs-comment"> * the object after this call.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recycle</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (DEBUG_RECYCLE) mStack = <span class="hljs-literal">null</span>;<br>    freeBuffer();<br>    <span class="hljs-keyword">final</span> Parcel[] pool;<br><br>    <span class="hljs-comment">//根据mNativePtr标志，将当前Parcel对象回收到sOwnedPool或者sHolderPool池中。</span><br>    <span class="hljs-keyword">if</span> (mOwnsNativeParcelObject) &#123;<br>        pool = sOwnedPool;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        mNativePtr = <span class="hljs-number">0</span>;<br>        pool = sHolderPool;<br>    &#125;<br><br>    <span class="hljs-comment">//找到池子中的空位置，存放当前回收的Parcel对象实例。</span><br>    <span class="hljs-keyword">synchronized</span> (pool) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;POOL_SIZE; i++) &#123;<br>            <span class="hljs-keyword">if</span> (pool[i] == <span class="hljs-literal">null</span>) &#123;<br>                pool[i] = <span class="hljs-built_in">this</span>;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-读写数据"><a href="#2-读写数据" class="headerlink" title="2.读写数据"></a>2.读写数据</h3><p>​    获取到<code>Parcel</code>对象之后，让我们来看看能够进行什么操作。首先就是数据的写入和读取，因为<code>Parcel</code>大部分方法都围绕着读取和写入各种类型的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//写入方法</span><br>writeArray()<br>writeArrayMap()<br>writeArraySet()<br>writeBinderArray()<br>     ......<br>     <br><span class="hljs-comment">//读取方法</span><br>readArray()<br>readArrayList()<br>readArrayMap()<br>readArraySet()<br>readBinderArray()<br>......<br></code></pre></td></tr></table></figure><p>​    通常在按顺序读取数据之前需要先用setDataPosition(int pos)方法将读取偏移到0，也就是从头开始读取。也可以移到指定的偏移位置读取数据。</p><h3 id="3-native实现"><a href="#3-native实现" class="headerlink" title="3.native实现"></a>3.native实现</h3><p>Android中很多java类都是c++类的封装，Parcel也是如此</p><h4 id="3-1-获取Parcel实例"><a href="#3-1-获取Parcel实例" class="headerlink" title="3.1 获取Parcel实例"></a>3.1 获取Parcel实例</h4><p>java层的obtain调用到了java层的init方法中，init方法中调用了native方法 <code>nativeCreate</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">long</span> nativePtr)</span> &#123;<br>    <span class="hljs-keyword">if</span> (nativePtr != <span class="hljs-number">0</span>) &#123;<br>        mNativePtr = nativePtr;<br>        mOwnsNativeParcelObject = <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//如果nativePtr为0,也就是还没有native对象</span><br>        mNativePtr = nativeCreate();<br>        mOwnsNativeParcelObject = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据JNI方法映射找到对应的native方法 <code>android_os_Parcel_create</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//frameworks/base/core/jni/android_os_Parcel.cpp  </span><br>    <br><span class="hljs-type">static</span> <span class="hljs-type">const</span> JNINativeMethod gParcelMethods[] = &#123;<br>        ...<br>        <span class="hljs-comment">// @FastNative</span><br>        &#123;<span class="hljs-string">&quot;nativeWriteInt&quot;</span>,            <span class="hljs-string">&quot;(JI)V&quot;</span>, (<span class="hljs-type">void</span>*)android_os_Parcel_writeInt&#125;,<br>        ...<br>        &#123;<span class="hljs-string">&quot;nativeReadByteArray&quot;</span>,       <span class="hljs-string">&quot;(J[BI)Z&quot;</span>, (<span class="hljs-type">void</span>*)android_os_Parcel_readByteArray&#125;,<br>        &#123;<span class="hljs-string">&quot;nativeReadBlob&quot;</span>,            <span class="hljs-string">&quot;(J)[B&quot;</span>, (<span class="hljs-type">void</span>*)android_os_Parcel_readBlob&#125;,<br>        <span class="hljs-comment">// @CriticalNative</span><br>        &#123;<span class="hljs-string">&quot;nativeReadInt&quot;</span>,             <span class="hljs-string">&quot;(J)I&quot;</span>, (<span class="hljs-type">void</span>*)android_os_Parcel_readInt&#125;,<br>        ...<br>        &#123;<span class="hljs-string">&quot;nativeCreate&quot;</span>,              <span class="hljs-string">&quot;()J&quot;</span>, (<span class="hljs-type">void</span>*)android_os_Parcel_create&#125;,<br>        ...<br>    &#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-function"><span class="hljs-type">static</span> jlong <span class="hljs-title">android_os_Parcel_create</span><span class="hljs-params">(JNIEnv* env, jclass clazz)</span></span><br><span class="hljs-function"></span>&#123;<br>     <span class="hljs-comment">//生成native层的parcel对象实例</span><br>    Parcel* parcel = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Parcel</span>();<br>     <span class="hljs-comment">//调用reinterpret_cast，reinterpret_cast 是 C++ 中的标准运算符</span><br>     <span class="hljs-comment">//将 Parcel* 指针转换为 jlong 类型。jlong 是一个 64 位的整型，足以容纳指针的值。因此，这个 jlong 实际上保存了 Parcel 实例在内存中的地址。</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;jlong&gt;(parcel);<br>&#125;<br></code></pre></td></tr></table></figure><p>native层的构造方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Parcel::<span class="hljs-built_in">Parcel</span>()<br>&#123;<br>    <span class="hljs-built_in">LOG_ALLOC</span>(<span class="hljs-string">&quot;Parcel %p: constructing&quot;</span>, <span class="hljs-keyword">this</span>);<br>    <span class="hljs-built_in">initState</span>();<br>&#125;<br><br><span class="hljs-comment">//初始化底层必要的一些数据</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Parcel::initState</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">LOG_ALLOC</span>(<span class="hljs-string">&quot;Parcel %p: initState&quot;</span>, <span class="hljs-keyword">this</span>);<br>    mError = NO_ERROR;<br>    mData = <span class="hljs-literal">nullptr</span>;<br>    mDataSize = <span class="hljs-number">0</span>;<br>    mDataCapacity = <span class="hljs-number">0</span>;<br>    mDataPos = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;initState Setting data size of %p to %zu&quot;</span>, <span class="hljs-keyword">this</span>, mDataSize);<br>    <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;initState Setting data pos of %p to %zu&quot;</span>, <span class="hljs-keyword">this</span>, mDataPos);<br>    mObjects = <span class="hljs-literal">nullptr</span>;<br>    mObjectsSize = <span class="hljs-number">0</span>;<br>    mObjectsCapacity = <span class="hljs-number">0</span>;<br>    mNextObjectHint = <span class="hljs-number">0</span>;<br>    mObjectsSorted = <span class="hljs-literal">false</span>;<br>    mHasFds = <span class="hljs-literal">false</span>;<br>    mFdsKnown = <span class="hljs-literal">true</span>;<br>    mAllowFds = <span class="hljs-literal">true</span>;<br>    mOwner = <span class="hljs-literal">nullptr</span>;<br>    mOpenAshmemSize = <span class="hljs-number">0</span>;<br>    mWorkSourceRequestHeaderPosition = <span class="hljs-number">0</span>;<br>    mRequestHeaderPresent = <span class="hljs-literal">false</span>;<br>    ... ...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-2-写数据"><a href="#3-2-写数据" class="headerlink" title="3.2 写数据"></a>3.2 写数据</h4><p>也是通过JNI从java层调用到cpp层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Write an integer value into the parcel at the current dataPosition(),</span><br><span class="hljs-comment"> * growing dataCapacity() if needed.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">//java层的writeInt方法，   parcel.writeInt(20)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeInt</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>    nativeWriteInt(mNativePtr, val);<br>&#125;<br><br><span class="hljs-comment">//native层的对应方法</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">android_os_Parcel_writeInt</span><span class="hljs-params">(JNIEnv* env, jclass clazz, jlong nativePtr, jint val)</span> &#123;<br>    Parcel* parcel = reinterpret_cast&lt;Parcel*&gt;(nativePtr);<br>    <span class="hljs-keyword">if</span> (parcel != NULL) &#123;<br>        const <span class="hljs-type">status_t</span> <span class="hljs-variable">err</span> <span class="hljs-operator">=</span> parcel-&gt;writeInt32(val);<br>        <span class="hljs-keyword">if</span> (err != NO_ERROR) &#123;<br>            signalExceptionForError(env, clazz, err);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先从Java层获取native层对象实例，然后调用native层的writeInt32方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">Parcel::writeInt32</span><span class="hljs-params">(<span class="hljs-type">int32_t</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">writeAligned</span>(val);<br>&#125;<br><br><span class="hljs-comment">//继续调用到writeAligned方法</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">Parcel::writeAligned</span><span class="hljs-params">(T val)</span> </span>&#123;<br>    <span class="hljs-built_in">COMPILE_TIME_ASSERT_FUNCTION_SCOPE</span>(<span class="hljs-built_in">PAD_SIZE_UNSAFE</span>(<span class="hljs-built_in">sizeof</span>(T)) == <span class="hljs-built_in">sizeof</span>(T));<br>    <span class="hljs-keyword">if</span> ((mDataPos+<span class="hljs-built_in">sizeof</span>(val)) &lt;= mDataCapacity) &#123;<br>restart_write:<br>        *<span class="hljs-built_in">reinterpret_cast</span>&lt;T*&gt;(mData+mDataPos) = val;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">finishWrite</span>(<span class="hljs-built_in">sizeof</span>(val));<br>    &#125;<br>    <span class="hljs-comment">//扩容</span><br>    <span class="hljs-type">status_t</span> err = <span class="hljs-built_in">growData</span>(<span class="hljs-built_in">sizeof</span>(val));<br>    <span class="hljs-keyword">if</span> (err == NO_ERROR) <span class="hljs-keyword">goto</span> restart_write;<br>    <span class="hljs-keyword">return</span> err;<br>&#125;<br></code></pre></td></tr></table></figure><p>writeAligned从字面意思看是对齐写，其中<br><code>COMPILE_TIME_ASSERT_FUNCTION_SCOPE</code> 是一个编译时断言，确保 <code>PAD_SIZE_UNSAFE(sizeof(T))</code> 的值等于 <code>sizeof(T)</code>。这表明对于类型 <code>T</code> 的大小在对齐时没有额外的填充（padding），即 <code>T</code> 的大小已经是对齐的，符合内存对齐的要求。</p><p>也就是说方法中调用sizeof(val)的时候会自动计算扩容后的size.</p><p><strong>对齐的意义：</strong></p><blockquote><p>大多数 CPU 会在访问内存时以特定的字长（如 4 字节、8 字节等）为单位进行数据传输。若数据按字长对齐，CPU 可以在一次内存访问中获取完整的数据，减少访问次数。</p><p>但是像char类型只有一个字节,因此实际上写入的时候要对齐写入成4个字节。</p></blockquote><h4 id="3-3-读数据"><a href="#3-3-读数据" class="headerlink" title="3.3 读数据"></a>3.3 读数据</h4><p>读数据也是Java-&gt;JNI-&gt;native的过程</p><p>java层的readInt</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">readInt</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> nativeReadInt(mNativePtr);<br>&#125;<br></code></pre></td></tr></table></figure><p>调用到native层</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//android_os_Parcel.cpp</span><br><span class="hljs-function"><span class="hljs-type">static</span> jint <span class="hljs-title">android_os_Parcel_readInt</span><span class="hljs-params">(jlong nativePtr)</span></span><br><span class="hljs-function"></span>&#123;<br>    Parcel* parcel = <span class="hljs-built_in">reinterpret_cast</span>&lt;Parcel*&gt;(nativePtr);<br>    <span class="hljs-keyword">if</span> (parcel != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> parcel-&gt;<span class="hljs-built_in">readInt32</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用到native层Parcel实例的readInt32方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">Parcel::readInt32</span><span class="hljs-params">(<span class="hljs-type">int32_t</span> *pArg)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">readAligned</span>(pArg);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">Parcel::readAligned</span><span class="hljs-params">(T *pArg)</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-built_in">COMPILE_TIME_ASSERT_FUNCTION_SCOPE</span>(<span class="hljs-built_in">PAD_SIZE_UNSAFE</span>(<span class="hljs-built_in">sizeof</span>(T)) == <span class="hljs-built_in">sizeof</span>(T));<br>    <span class="hljs-keyword">if</span> ((mDataPos+<span class="hljs-built_in">sizeof</span>(T)) &lt;= mDataSize) &#123;<br>        <span class="hljs-keyword">if</span> (mObjectsSize &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">status_t</span> err = <span class="hljs-built_in">validateReadData</span>(mDataPos + <span class="hljs-built_in">sizeof</span>(T));<br>            <span class="hljs-keyword">if</span>(err != NO_ERROR) &#123;<br>                <span class="hljs-comment">// Still increment the data position by the expected length</span><br>                mDataPos += <span class="hljs-built_in">sizeof</span>(T);<br>                <span class="hljs-keyword">return</span> err;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">const</span> <span class="hljs-type">void</span>* data = mData+mDataPos;<br>        mDataPos += <span class="hljs-built_in">sizeof</span>(T);<br>        *pArg =  *<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> T*&gt;(data);<br>        <span class="hljs-keyword">return</span> NO_ERROR;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> NOT_ENOUGH_DATA;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-两个对象池"><a href="#4-两个对象池" class="headerlink" title="4. 两个对象池"></a>4. 两个对象池</h3><p>在Parcel中涉及到了两个池子：<code>sOwnedPool</code> 和 <code>sHolderPool</code>。这两个池子的存在是为了更好地管理 Parcel 对象的生命周期，并针对不同的使用场景进行优化。</p><h4 id="4-1-两个池子的区别："><a href="#4-1-两个池子的区别：" class="headerlink" title="4.1 两个池子的区别："></a>4.1 <strong>两个池子的区别：</strong></h4><ul><li><p><strong><code>sOwnedPool</code> (Owned Pool):</strong> 这个池子用于存储<strong>拥有本地 Parcel 对象</strong>的 Parcel 实例。这里的“拥有”指的是 Parcel 对象在其内部维护了一个本地的内存缓冲区，用于存储序列化的数据。这些 Parcel 对象通常是通过 <code>Parcel.obtain()</code> 方法获取的。</p><p>这个池子的对象的内存空间都在当前进程的用户空间。</p></li><li><p><strong><code>sHolderPool</code> (Holder Pool):</strong> 这个池子用于存储<strong>持有外部 Parcel 对象</strong>的 Parcel 实例。这里的“持有”指的是 Parcel 对象并没有在其内部维护本地的内存缓冲区，而是持有一个指向外部内存缓冲区的指针。<strong>这些 Parcel 对象通常是在跨进程通信中，由 Binder 驱动程序创建并传递给接收进程的，不是通过是Parcel.obtain()方法获取的。</strong></p><p>这个池子的对象都是跨进程传输过来的，所指向的内存地址是用户空间和内核空间通过mmap映射的共享内存。</p></li></ul><h4 id="4-2-为什么要设计两个池子？"><a href="#4-2-为什么要设计两个池子？" class="headerlink" title="4.2 为什么要设计两个池子？"></a>4.2 <strong>为什么要设计两个池子？</strong></h4><p>设计两个池子的主要原因是为了<strong>区分和管理不同类型的 Parcel 对象，并针对性地进行优化</strong>。具体来说：</p><ol><li><strong>内存管理：</strong><ul><li><code>sOwnedPool</code> 中的 Parcel 对象拥有自己的内存缓冲区，因此在 <code>recycle()</code> 时需要释放这些缓冲区，以避免内存泄漏。<code>freeBuffer()</code> 方法就是用于释放这些缓冲区的。</li><li><code>sHolderPool</code> 中的 Parcel 对象不拥有自己的内存缓冲区，它们只是持有外部缓冲区的指针。这些缓冲区通常<strong>由 Binder 驱动程序管理</strong>，因此在 <code>recycle()</code> 时不需要释放缓冲区，只需要将指针重置为 0 即可。这避免了重复释放内存可能导致的错误。</li></ul></li><li><strong>性能优化：</strong><ul><li>通过区分两种类型的 Parcel 对象，可以避免不必要的内存操作。例如，在回收 <code>sHolderPool</code> 中的 Parcel 对象时，不需要执行 <code>freeBuffer()</code> 操作，从而提高了回收效率。</li><li>在跨进程通信中，接收进程通常会频繁地接收和处理 Parcel 对象。将这些对象放到单独的 <code>sHolderPool</code> 中，可以更快地进行回收和重用，从而提高 IPC 的性能。</li></ul></li><li><strong>避免错误：</strong><ul><li>如果只有一个池子，那么在回收 Parcel 对象时就需要判断其是否拥有本地缓冲区，并根据情况执行不同的操作。这增加了代码的复杂性，也更容易出错。通过使用两个池子，可以将这些逻辑分离，使代码更加清晰和易于维护。</li></ul></li></ol><h4 id="4-3-举例说明："><a href="#4-3-举例说明：" class="headerlink" title="4.3 举例说明："></a>4.3 <strong>举例说明：</strong></h4><ol><li><p><strong>进程 A 调用进程 B 的某个方法：</strong></p><ul><li><p>进程 A 使用 <code>Parcel.obtain()</code> 获取一个 Parcel 对象 <code>p1</code>（属于 <code>sOwnedPool</code>）。</p></li><li><p>进程 A 将数据写入 <code>p1</code>。</p></li><li><p>Binder 驱动程序将 <code>p1</code> 中的数据复制到一块共享内存区域，并创建一个新的 Parcel 对象 <code>p2</code>（属于 <code>sHolderPool</code>），<code>p2</code> 持有指向共享内存区域的指针。</p></li><li><p>Binder 驱动程序将 <code>p2</code> 传递给进程 B。</p></li><li><p>进程 B 从 <code>p2</code> 读取数据。</p></li><li><p>进程 B 调用 <code>p2.recycle()</code>，<code>p2</code> 被回收到 <code>sHolderPool</code>。</p></li><li><p>进程 A 完成操作后，调用 <code>p1.recycle()</code>，<code>p1</code> 被回收到 <code>sOwnedPool</code>，并且其内部的缓冲区会被释放。</p><p><strong>p1和p2分别对应进程A的是sOwnedPool和进程B的sHolderPool，被各自回收。</strong></p></li></ul></li><li><p><strong>进程内部使用 Parcel：</strong></p><ul><li>在同一个进程内部使用 Parcel 时，通常只会使用 <code>sOwnedPool</code> 中的 Parcel 对象。</li></ul></li></ol><h4 id="4-4-总结："><a href="#4-4-总结：" class="headerlink" title="4.4 总结："></a>4.4 <strong>总结：</strong></h4><p><code>sOwnedPool</code> 和 <code>sHolderPool</code> 的设计是为了更好地管理不同类型的 Parcel 对象，并针对不同的使用场景进行优化。通过区分拥有本地缓冲区的 Parcel 对象和持有外部缓冲区的 Parcel 对象，可以提高内存管理效率、IPC 性能，并减少代码错误。这是一种巧妙的设计，体现了 Android 框架在性能优化方面的考虑。</p><h2 id="二、-Parcelable接口的概念"><a href="#二、-Parcelable接口的概念" class="headerlink" title="二、 Parcelable接口的概念"></a>二、 Parcelable接口的概念</h2><p> Android开发中常常用到序列化，典型的应用就是<a href="https://www.androidos.net.cn/android/10.0.0_r6/xref/frameworks/base/core/java/android/content/Intent.java">Intent</a>携带数据(不宜携带过多数据)。跨进程传输是将对象序列化，转换成可存储或可传输的状态，再通过网络等方式传输。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Intent</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Parcelable</span>, Cloneable &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>​    <a href="https://www.androidos.net.cn/android/10.0.0_r6/xref/frameworks/base/core/java/android/content/Intent.java">Intent</a>之所以能够跨进程传输因为它实现了Android特有的序列化接口<code>Parcelable</code>。这也是开发中用到序列化的原因之一：</p><p>​    ①永久性保存对象，保存对象的字节序列到本地文件</p><p>​    ②通过序列化对象在网络中传递对象 </p><p>​    ③通过序列化对象在进程间传递对象</p><h3 id="2-1-Serialable"><a href="#2-1-Serialable" class="headerlink" title="2.1 Serialable"></a>2.1 Serialable</h3><p>​    <a href="https://www.androidos.net.cn/android/10.0.0_r6/xref/frameworks/base/core/java/android/os/Parcelable.java">Serialable</a>是Java自带的序列化接口：表示将一个对象转换成可存储或可传输的状态。序列化后的对象可以在网络上进行传输，也可以存储到本地。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Serializable</span> &#123;<br> <br>&#125;<br></code></pre></td></tr></table></figure><p>​    需要序列化的类，实现<a href="https://www.androidos.net.cn/android/10.0.0_r6/xref/frameworks/base/core/java/android/os/Parcelable.java">Serialable</a>接口声明一下该类需要序列化即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Info</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">974450303339087901L</span>;<br><br><span class="hljs-keyword">private</span> String name;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    注意需要提供一个serialVersionUID常量，标识独一无二的一个类。参考<a href="http://quibbler.cn/?thread-203.htm">生成Serializable接口serialVersionUID</a>。</p><h3 id="2-2-Parcelable"><a href="#2-2-Parcelable" class="headerlink" title="2.2  Parcelable"></a>2.2  Parcelable</h3><p>​    Parcelable序列化是Android独有的序列化方式。</p><p>​    为什么不直接采用Java自带的Serialable序列化呢？Serializable效率过慢，而Parcelable比Serializable性能高。Serializable在序列化的时候会产生大量的临时变量，从而引起频繁的GC。对于Android应用程序运行在移动设备上，对性能有一定的要求。</p><h4 id="1-Parcelable接口"><a href="#1-Parcelable接口" class="headerlink" title="1 Parcelable接口"></a>1 Parcelable接口</h4><p>​    <strong>①</strong>两个抽象方法，序列化必须要实现：</p><p>​    public int describeContents()：内容描述接口，不用管。返回0即可。</p><p>​    public void writeToParcel(Parcel dest, int flags)：数据写入序列流接口。</p><p>​    <strong>②</strong>两个接口：必须创建实现Creator<T>接口的静态实例，并且名称为CREATOR。</p><p>​    Creator<T>，必须作为公共CREATOR字段实现并提供的接口，该字段从Parcel生成Parcelable类的实例T。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Creator</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建Parcelable类的新实例，然后从给定的Parcel实例化该实例。该数据先前由Parcelable#writeToParcel写入</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">createFromParcel</span><span class="hljs-params">(Parcel source)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建一个新的Parcelable类数组</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> T[] newArray(<span class="hljs-type">int</span> size);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-标准实例"><a href="#2-标准实例" class="headerlink" title="2 标准实例"></a>2 标准实例</h4><p>通过Parcelable序列化的典型实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyParcelable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Parcelable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> mData;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">describeContents</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeToParcel</span><span class="hljs-params">(Parcel out, <span class="hljs-type">int</span> flags)</span> &#123;<br>        out.writeInt(mData);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Parcelable.Creator&lt;MyParcelable&gt; CREATOR<br>            = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parcelable</span>.Creator&lt;MyParcelable&gt;() &#123;<br>        <span class="hljs-keyword">public</span> MyParcelable <span class="hljs-title function_">createFromParcel</span><span class="hljs-params">(Parcel in)</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyParcelable</span>(in);<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> MyParcelable[] newArray(<span class="hljs-type">int</span> size) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyParcelable</span>[size];<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">MyParcelable</span><span class="hljs-params">(Parcel in)</span> &#123;<br>        mData = in.readInt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 三个要点：实现两个接口方法；创建一个实现Creator<T>接口的静态实例，并且名称为CREATOR；数据序列化顺序和反序列化顺序要一致。</p><p>​    如果需要序列化的类属性过多，一个一个写起来挺麻烦。推荐一个<a href="http://quibbler.cn/?thread-530.htm">Parcelable序列化插件</a>款速实现Parcelable序列化。</p><h3 id="2-3、总结"><a href="#2-3、总结" class="headerlink" title="2.3、总结"></a>2.3、总结</h3><ul><li>Serializable是Java自带的序列化方式，Parcelable是Android特有的序列化方式。</li><li>Serializable序列化会产生大量的临时变量，引起频繁的GC，造成内存抖动，不适合Android应用程序。</li><li>Parcelable比Serializable性能高、效率高，Android开发中使用Parcelable。</li><li>Serializable可以将对象通过网络传输 或 磁盘存储。Parcelable无法将对象保存在存储中。</li></ul><h2 id="三、parcel类和Parcelable接口"><a href="#三、parcel类和Parcelable接口" class="headerlink" title="三、parcel类和Parcelable接口"></a>三、parcel类和Parcelable接口</h2><p><code>Parcel</code>类是一个android定义好的容器，用来进行跨进程传输。<br>而<code>Parceable</code>是一个接口，如果我自定义的类需要进行跨进程的传输，那么我就要实现这个接口，只有这样，才能够将自定义的类写入到Parcel对象中，利用Parcel进行跨进行传输</p><ol><li><strong>Parcel 类</strong>：</li></ol><ul><li><code>Parcel</code> 是一个 Android 框架提供的类，用作数据的容器。它用于在进程之间传输数据，特别是在 IPC（进程间通信）中。</li><li><code>Parcel</code> 提供了一组方法，可以用来将基本数据类型、对象和数组等数据序列化（写入）和反序列化（读取）。它可以有效地在内存中存储和传递数据。</li></ul><p>2.<strong>Parcelable 接口</strong>：</p><ul><li>Parcelable 是一个接口，定义了如何将对象写入 Parcel。任何希望通过 Parcel 进行传输的自定义类都需要实现这个接口。</li><li>实现 Parceable 接口需要实现两个方法：<ul><li><code>writeToParcel(Parcel dest, int flags)</code>：将对象的字段写入到 <code>Parcel</code> 中。</li><li><code>Parcelable.Creator&lt;T&gt;</code>：一个静态的创建者，用于创建从 <code>Parcel</code> 中读取的对象。它负责将数据从 <code>Parcel</code> 中反序列化为对象。</li></ul></li></ul><p>3.<strong>自定义类的使用</strong>：</p><ul><li>当你定义一个自定义类并希望通过 <code>Parcel</code> 进行跨进程传输时，你需要实现 <code>Parcelable</code> 接口。这样，系统才能知道如何将你的对象转换为适合传输的格式，并在需要时重新创建它。</li><li>例如，在使用 <code>Intent</code> 传递数据时，可以将实现了 <code>Parcelable</code> 接口的对象作为 <code>Intent</code> 的额外数据传递。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Parcel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Messenger</title>
    <link href="/2025/01/04/Messenger/"/>
    <url>/2025/01/04/Messenger/</url>
    
    <content type="html"><![CDATA[<blockquote><p>参考： <a href="https://blog.csdn.net/learnframework/article/details/119845833">blog.csdn.net</a></p></blockquote><h3 id="一、Messenger-是什么？"><a href="#一、Messenger-是什么？" class="headerlink" title="一、Messenger 是什么？"></a>一、Messenger 是什么？</h3><p><strong>Messenger 是基于 AIDL 实现的轻量级 IPC 方案</strong>。<br>这里立马就会有疑问为什么要它呢？明明有了 aidl  </p><p>通过aidl实现binder有些复杂，如果上节课大家学完了 aidl 进行 binder 通信是否感觉到使用起来其实还是有点复杂，毕竟通信什么的要写 aidl，而且客户端和服务端都需要 aidl 文件，两个过程里面都需要，相对来说还是比较麻烦，对于项目过程中可能就是一些简单的跨进程数据传递，就是调用几个非常非常简单的方法，很多觉得都要写 aidl 成本比较大，那么有没有更加简单的方案来解决这个问题呢？  </p><p>使用方法：</p><ol><li><p>服务端：实现一个Handler，用于处理客户端发来的跨进程通信信息</p></li><li><p>服务端：以实现的Handler实例为参数，创建一个Messenger实例。（Messenget实例中的target属性是IMessenget.stub实例）</p></li><li><p>服务端：在onBind中，将 messenger.getBinder() 跨进程传递给客户端。（传递就是target这个Binder对象）</p></li><li><p>客户端：在onServiceConnected中，以返回的Binder实例来构造Messenger实例。（实例化了Messenger中target属性为IMessenget.Proxy实例）</p></li><li><p>客户端：通过调用Messenger.send 按照如下流程最终调用到服务端的Hadnler中。</p><p><img src="/./img/Messenger_image/image-20250104221027796.png" alt="Messenger跨进程调用流程"></p></li></ol><h3 id="二、服务端对-Messenger-的使用"><a href="#二、服务端对-Messenger-的使用" class="headerlink" title="二、服务端对 Messenger 的使用"></a>二、服务端对 Messenger 的使用</h3><p>服务端需要实现一个 Handler 用于处理客户端发来的跨进程通信信息：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> messengerHandler = <span class="hljs-keyword">object</span> : Handler(Looper.getMainLooper()) &#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(msg: <span class="hljs-type">Message</span>)</span></span> &#123;<br>            <span class="hljs-keyword">when</span> (msg.what) &#123;<br>                <span class="hljs-number">1</span> -&gt; &#123;<br>                    Log.i(<span class="hljs-string">&quot;test&quot;</span>,<br>                        <span class="hljs-string">&quot;MessengerService Messenger handleMessage msg = <span class="hljs-variable">$msg</span>&quot;</span> +<br>                                <span class="hljs-string">&quot; bundle key value = <span class="hljs-subst">$&#123;msg.data.getString(<span class="hljs-string">&quot;bundleKey&quot;</span>)&#125;</span>&quot;</span>)<br>                    <span class="hljs-comment">//客户端将自身的Messenger发送通过，服务端通过这个实例来进行双向通信</span><br>                    <span class="hljs-keyword">val</span> clientSend = msg.replyTo<br>                    <span class="hljs-keyword">val</span> toClientMsg = Message.obtain().apply &#123;<br>                        what = <span class="hljs-number">2</span><br>                        <span class="hljs-comment">// obj = &quot;I am reply from Server&quot;</span><br>                    &#125;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">//与Client通信</span><br>                        clientSend.send(toClientMsg)<br>                    &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;<br>                        Log.i(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;MessengerService clientSend error &quot;</span>, e)<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">super</span>.handleMessage(msg)<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>然后服务端构造出对应的 Messenger：<br>服务端构造：  </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//创建messenger对象，参数是自定义的Handler对象</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> messenger = Messenger(messengerHandler)<br></code></pre></td></tr></table></figure><p>最后，当服务端的 onBinder 回调时候要返回 Messenger 的 IBinder 对象给客户端</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onBind</span><span class="hljs-params">(intent: <span class="hljs-type">Intent</span>)</span></span>: IBinder &#123;<br>    <span class="hljs-keyword">return</span> messenger.getBinder()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三、客户端的使用"><a href="#三、客户端的使用" class="headerlink" title="三、客户端的使用"></a>三、客户端的使用</h3><p>客户端还是和以前一样通过 bindService 在 ServiceConnection 类的 onServiceConnected 获取到服务端的返回的 IBinder，从而获取到服务端的 Messenger 代理类, 调用 send 函数发送 Message。所以 Messenger 能发送的信息只有 Message 能携带的信息。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> onButtonClick1: () -&gt; <span class="hljs-built_in">Unit</span> = &#123;<br>    <span class="hljs-keyword">var</span> intent = Intent(context, MessengerService::<span class="hljs-keyword">class</span>.java)<br>    context.bindService(intent, <span class="hljs-keyword">object</span>:ServiceConnection &#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onServiceConnected</span><span class="hljs-params">(name: <span class="hljs-type">ComponentName</span>?, service: <span class="hljs-type">IBinder</span>?)</span></span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Log.i(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;MessengerService  onServiceConnected name = <span class="hljs-variable">$name</span>&quot;</span>)<br>                <span class="hljs-comment">//保存service端的Messenger对象</span><br>                context.messengerServer = Messenger(service)<br>                <span class="hljs-comment">//通过自定义的sendMessageToServer方法，将client端本地的Messenger对象传递给server端</span><br>                context.sendMessageToServer()<br>            &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;<br>                e.printStackTrace()<br>                Log.i(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;error &quot;</span>, e)<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onServiceDisconnected</span><span class="hljs-params">(p0: <span class="hljs-type">ComponentName</span>?)</span></span> &#123;<br>            Log.d(TAG, <span class="hljs-string">&quot;client onServiceDisconnected name = <span class="hljs-variable">$name</span>&quot;</span>)<br>        &#125;<br><br>    &#125;, BIND_AUTO_CREATE)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sendMessageToServer</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">//new 一个Message消息对象</span><br>    <span class="hljs-keyword">var</span> toServerMessage = Message.obtain()<br>    <span class="hljs-comment">//在Message消息对象中添加client端的Messenger实例</span><br>    toServerMessage.replyTo = messengerClient<br>    toServerMessage.what = <span class="hljs-number">1</span><br><br>    <span class="hljs-comment">//自定义的参数，需要通过Bundle类传递</span><br>    <span class="hljs-keyword">val</span> bundle:Bundle = Bundle()<br>    bundle.putString(<span class="hljs-string">&quot;bundleKey&quot;</span>, <span class="hljs-string">&quot;bundleValue from Client&quot;</span>)<br>    toServerMessage.<span class="hljs-keyword">data</span> = bundle<br>    <span class="hljs-comment">//通过service端的messenger对象调用远程方法</span><br>    messengerServer?.send(toServerMessage)<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>客户端获取了服务端 IBinder 对象后，用它来构造客户端的 Messenger，<br>messengerServer &#x3D; new Messenger(service);  </p></li><li><p>有了服务端 Messenger 后，那么就可以通过它与服务端进行通信了，通信的内容载体是我们 Message，对他就是和 Handler 搭配的 Message，它就是具体消息体，即你需要发送什么消息，都是把内容转换成 Message 对象既可以。</p><p>这里我们案例中传递一个 Bundle 的对象，这个 Bundle 对象可以利用键值对方式装载各种各样类型数据。</p><p>和 Intent 传递数据 Bundle 是一样的。</p><p><strong>注意这里 message 对象还有一个属性是 replyTo ，这个是 Messenger 类型的</strong>，字面意思就是说这个消息发送过去，如果对方需要回复，就可以通过消息中的 replyTo 的 Messenger 对象来进行回复，这里是不是也和我们上节课讲的 binder 双向通信一样，所以说 Messenger 这种方式本身就相当于自带了双向通信</p></li></ol><h3 id="四、Messenger-本质原理"><a href="#四、Messenger-本质原理" class="headerlink" title="四、Messenger 本质原理"></a>四、Messenger 本质原理</h3><p>Messenger 其实本质上也是使用 aidl 进行实现了，只是这个 aidl 是在 Framework 层面进行写好了，不需要你写，你也就没有在意，没有看到。这里对他的源码进行分析一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Messenger</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Parcelable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> IMessenger mTarget;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Create a new Messenger pointing to the given Handler.  Any Message</span><br><span class="hljs-comment">     * objects sent through this Messenger will appear in the Handler as if</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@link</span> Handler#sendMessage(Message) Handler.sendMessage(Message)&#125; had</span><br><span class="hljs-comment">     * been called directly.</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> target The Handler that will receive sent messages.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Messenger</span><span class="hljs-params">(Handler target)</span> &#123;<br>        mTarget = target.getIMessenger();<span class="hljs-comment">//这个是handler对象获取IMessenger接口</span><br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Send a Message to this Messenger&#x27;s Handler.</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message The Message to send.  Usually retrieved through</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@link</span> Message#obtain() Message.obtain()&#125;.</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> RemoteException Throws DeadObjectException if the target</span><br><span class="hljs-comment">     * Handler no longer exists.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(Message message)</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br>        mTarget.send(message);<span class="hljs-comment">//这其实调用是IMessenger接口的send</span><br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Retrieve the IBinder that this Messenger is using to communicate with</span><br><span class="hljs-comment">     * its associated Handler.</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> Returns the IBinder backing this Messenger.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> IBinder <span class="hljs-title function_">getBinder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> mTarget.asBinder();<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Create a Messenger from a raw IBinder, which had previously been</span><br><span class="hljs-comment">     * retrieved with &#123;<span class="hljs-doctag">@link</span> #getBinder&#125;.</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> target The IBinder this Messenger should communicate with.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Messenger</span><span class="hljs-params">(IBinder target)</span> &#123;<br>        mTarget = IMessenger.Stub.asInterface(target);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>代码中注释提到的 handler 对象获取 IMessenger 接口，IMessenger 接口到底又是什么呢？<br>目前我没没有看到有 aidl 啊。。。</p><p>Handler 的 getIMessenger</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@UnsupportedAppUsage</span><br>    <span class="hljs-keyword">final</span> IMessenger <span class="hljs-title function_">getIMessenger</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (mQueue) &#123;<br>            <span class="hljs-keyword">if</span> (mMessenger != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> mMessenger;<br>            &#125;<br>            mMessenger = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessengerImpl</span>();<br>            <span class="hljs-keyword">return</span> mMessenger;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessengerImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">IMessenger</span>.Stub &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(Message msg)</span> &#123;<br>            msg.sendingUid = Binder.getCallingUid();<br>            Handler.<span class="hljs-built_in">this</span>.sendMessage(msg);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>大家看这里其实就是 MessengerImpl ，是继承 IMessenger.Stub，大家看到 IMessenger.Stub 是不是和 aidl 里面的接口和很熟悉啊。对它其实就是 IMessenger.aidl 文件生成的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> android.os;<br><br><span class="hljs-keyword">import</span> android.os.Message;<br><br><span class="hljs-comment">/** <span class="hljs-doctag">@hide</span> */</span><br>oneway <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IMessenger</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(in Message msg)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里是不是看到期待已久的 aidl 了。。还是个 oneway 类型的哦</p><p><img src="/./img/Messenger_image/image-20250104223436699.png" alt="Messenger结构"></p><p><strong>分析对应结构</strong></p><p>Messenger对象中有一个target属性，<strong>这个属性的类型是IMessenger，跨进程传输的就是这个对象，</strong>Messenger类是对这个Binder实现的进一层封装。<br><strong>在service端，target是一个IMessenger.Stub类型的实例。</strong><br><strong>在client端，target是一个IMessager.Proxy类型的实例。</strong></p><p>调用流程如下：<br><img src="/./img/Messenger_image/image-20250104221027796.png" alt="Messenger调用流程"></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binder</tag>
      
      <tag>AIDL</tag>
      
      <tag>Messenger</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android Binder通信</title>
    <link href="/2024/11/26/Android%20Binder%E9%80%9A%E4%BF%A1/"/>
    <url>/2024/11/26/Android%20Binder%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<p><strong>Android跨进程通信 从应用层到内核层</strong></p><p>Android Binder 通信是 Android 平台特有的一种跨进程通信机制，其本质是利用 Linux 内核进程间共享地址空间的特性，实现跨进程的数据传输。同时，Binder 针对数据传输进行了优化，在设计上能够实现仅一次拷贝的高效通信。</p><h3 id="1-应用层使用跨进程通信"><a href="#1-应用层使用跨进程通信" class="headerlink" title="1.应用层使用跨进程通信"></a>1.应用层使用跨进程通信</h3><p>Android Binder机制在应用层的使用通常会和<code>Service</code>一起出现，作为Service进程可以与绑定Service的Client进程进行通信。为了方便使用，出现了<code>AIDL</code>（Android Interface Definition Language 即<code>Android接口定义语言</code>）， 借助AIDL能够很快捷得实现跨进程通信。</p><h4 id="1-1-AIDL使用"><a href="#1-1-AIDL使用" class="headerlink" title="1.1 AIDL使用"></a>1.1 AIDL使用</h4><ol><li>定义一个aidl文件</li><li>build，通过aidl生成IxxInterface接口文件</li><li>服务端：自定义一个继承自Service组件的服务，并且注册到Manifest中(作为测试，需要设置单独进程运行)</li><li>服务端：service中需要在onBinder方法中返回一个IBinder对象，并且该对象需要实现Stub接口</li><li>客户端：构造Intent，包含远程Service包名类名</li><li>客户端：调用binderService，在ServiceConnected回调中获取服务端通过onBinder返回的IBinder对象，<strong>并转换成Proxy对象</strong></li><li>客户端：通过Proxy对象就可以远程调用服务端方法</li></ol><h5 id="1-新建aidl文件"><a href="#1-新建aidl文件" class="headerlink" title="1.新建aidl文件"></a>1.新建aidl文件</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// IMyAidlInterface.aidl</span><br><span class="hljs-keyword">package</span> com.zml.myapplication;<br><br><span class="hljs-comment">// Declare any non-default types here with import statements</span><br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IMyAidlInterface</span> &#123;<br>    <span class="hljs-comment">//get studentid using student name</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">getStudentId</span><span class="hljs-params">(String studentName)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-AS中重新Make一下就会生成接口对象"><a href="#2-AS中重新Make一下就会生成接口对象" class="headerlink" title="2.AS中重新Make一下就会生成接口对象"></a>2.AS中重新Make一下就会生成接口对象</h5><blockquote><p>本质上是调用了Sdk&#x2F;build-tools&#x2F;35.0.0&#x2F;aidl.exe文件。<br>生成路径：app&#x2F;build&#x2F;generated&#x2F;aidl_source_output_dir&#x2F;debug&#x2F;out&#x2F;com&#x2F;zml&#x2F;myapplication&#x2F;IMyAidlInterface.java</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * This file is auto-generated.  DO NOT MODIFY.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">package</span> com.zml.myapplication;<br><span class="hljs-comment">// Declare any non-default types here with import statements</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IMyAidlInterface</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">android</span>.os.IInterface<br>&#123;<br>    <span class="hljs-comment">//这个类通常是一个空实现，主要用于在没有实现AIDL接口的情况下提供一个默认的、非功能的实现。</span><br>  <span class="hljs-comment">/** Default implementation for IMyAidlInterface. */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Default</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">com</span>.zml.myapplication.IMyAidlInterface<br>  &#123;<br>    <span class="hljs-comment">//get studentid using student name</span><br><br>    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getStudentId</span><span class="hljs-params">(java.lang.String studentName)</span> <span class="hljs-keyword">throws</span> android.os.RemoteException<br>    &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> android.os.IBinder <span class="hljs-title function_">asBinder</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">//Stub类继承自Binder类，并实现了AIDL接口中定义的所有方法。它是服务端实现AIDL接口的核心部分</span><br>  <span class="hljs-comment">/** Local-side IPC implementation stub class. */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Stub</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">android</span>.os.Binder <span class="hljs-keyword">implements</span> <span class="hljs-title class_">com</span>.zml.myapplication.IMyAidlInterface<br>  &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> java.lang.<span class="hljs-type">String</span> <span class="hljs-variable">DESCRIPTOR</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;com.zml.myapplication.IMyAidlInterface&quot;</span>;<br>    <span class="hljs-comment">/** Construct the stub at attach it to the interface. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Stub</span><span class="hljs-params">()</span><br>    &#123;<br>      <span class="hljs-built_in">this</span>.attachInterface(<span class="hljs-built_in">this</span>, DESCRIPTOR);<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Cast an IBinder object into an com.zml.myapplication.IMyAidlInterface interface,</span><br><span class="hljs-comment">     * generating a proxy if needed.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> com.zml.myapplication.IMyAidlInterface <span class="hljs-title function_">asInterface</span><span class="hljs-params">(android.os.IBinder obj)</span><br>    &#123;<br>      <span class="hljs-keyword">if</span> ((obj==<span class="hljs-literal">null</span>)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>      &#125;<br>      android.os.<span class="hljs-type">IInterface</span> <span class="hljs-variable">iin</span> <span class="hljs-operator">=</span> obj.queryLocalInterface(DESCRIPTOR);<br>      <span class="hljs-keyword">if</span> (((iin!=<span class="hljs-literal">null</span>)&amp;&amp;(iin <span class="hljs-keyword">instanceof</span> com.zml.myapplication.IMyAidlInterface))) &#123;<br>        <span class="hljs-keyword">return</span> ((com.zml.myapplication.IMyAidlInterface)iin);<br>      &#125;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">com</span>.zml.myapplication.IMyAidlInterface.Stub.Proxy(obj);<br>    &#125;<br>    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> android.os.IBinder <span class="hljs-title function_">asBinder</span><span class="hljs-params">()</span><br>    &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onTransact</span><span class="hljs-params">(<span class="hljs-type">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="hljs-type">int</span> flags)</span> <span class="hljs-keyword">throws</span> android.os.RemoteException<br>    &#123;<br>      java.lang.<span class="hljs-type">String</span> <span class="hljs-variable">descriptor</span> <span class="hljs-operator">=</span> DESCRIPTOR;<br>      <span class="hljs-keyword">switch</span> (code)<br>      &#123;<br>        <span class="hljs-keyword">case</span> INTERFACE_TRANSACTION:<br>        &#123;<br>          reply.writeString(descriptor);<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> TRANSACTION_getStudentId:<br>        &#123;<br>          data.enforceInterface(descriptor);<br>          java.lang.String _arg0;<br>          _arg0 = data.readString();<br>          <span class="hljs-type">int</span> <span class="hljs-variable">_result</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getStudentId(_arg0);<br>          reply.writeNoException();<br>          reply.writeInt(_result);<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">default</span>:<br>        &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.onTransact(code, data, reply, flags);<br>        &#125;<br>      &#125;<br>    &#125;<br>          <span class="hljs-comment">//Proxy作为Stub的内部类，它实现了AIDL接口中的方法，但并不直接执行这些方法，而是转换为对Binder的跨进程调用</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">com</span>.zml.myapplication.IMyAidlInterface<br>    &#123;<br>      <span class="hljs-keyword">private</span> android.os.IBinder mRemote;<br>      Proxy(android.os.IBinder remote)<br>      &#123;<br>        mRemote = remote;<br>      &#125;<br>      <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> android.os.IBinder <span class="hljs-title function_">asBinder</span><span class="hljs-params">()</span><br>      &#123;<br>        <span class="hljs-keyword">return</span> mRemote;<br>      &#125;<br>      <span class="hljs-keyword">public</span> java.lang.String <span class="hljs-title function_">getInterfaceDescriptor</span><span class="hljs-params">()</span><br>      &#123;<br>        <span class="hljs-keyword">return</span> DESCRIPTOR;<br>      &#125;<br>      <span class="hljs-comment">//get studentid using student name</span><br><br>      <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getStudentId</span><span class="hljs-params">(java.lang.String studentName)</span> <span class="hljs-keyword">throws</span> android.os.RemoteException<br>      &#123;<br>        android.os.<span class="hljs-type">Parcel</span> <span class="hljs-variable">_data</span> <span class="hljs-operator">=</span> android.os.Parcel.obtain();<br>        android.os.<span class="hljs-type">Parcel</span> <span class="hljs-variable">_reply</span> <span class="hljs-operator">=</span> android.os.Parcel.obtain();<br>        <span class="hljs-type">int</span> _result;<br>        <span class="hljs-keyword">try</span> &#123;<br>          _data.writeInterfaceToken(DESCRIPTOR);<br>          _data.writeString(studentName);<br>          <span class="hljs-type">boolean</span> <span class="hljs-variable">_status</span> <span class="hljs-operator">=</span> mRemote.transact(Stub.TRANSACTION_getStudentId, _data, _reply, <span class="hljs-number">0</span>);<br>          <span class="hljs-keyword">if</span> (!_status &amp;&amp; getDefaultImpl() != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> getDefaultImpl().getStudentId(studentName);<br>          &#125;<br>          _reply.readException();<br>          _result = _reply.readInt();<br>        &#125;<br>        <span class="hljs-keyword">finally</span> &#123;<br>          _reply.recycle();<br>          _data.recycle();<br>        &#125;<br>        <span class="hljs-keyword">return</span> _result;<br>      &#125;<br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> com.zml.myapplication.IMyAidlInterface sDefaultImpl;<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TRANSACTION_getStudentId</span> <span class="hljs-operator">=</span> (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">setDefaultImpl</span><span class="hljs-params">(com.zml.myapplication.IMyAidlInterface impl)</span> &#123;<br>      <span class="hljs-comment">// Only one user of this interface can use this function</span><br>      <span class="hljs-comment">// at a time. This is a heuristic to detect if two different</span><br>      <span class="hljs-comment">// users in the same process use this function.</span><br>      <span class="hljs-keyword">if</span> (Stub.Proxy.sDefaultImpl != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;setDefaultImpl() called twice&quot;</span>);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (impl != <span class="hljs-literal">null</span>) &#123;<br>        Stub.Proxy.sDefaultImpl = impl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      &#125;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> com.zml.myapplication.IMyAidlInterface <span class="hljs-title function_">getDefaultImpl</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> Stub.Proxy.sDefaultImpl;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">//get studentid using student name</span><br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getStudentId</span><span class="hljs-params">(java.lang.String studentName)</span> <span class="hljs-keyword">throws</span> android.os.RemoteException;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="3-定义Service，并注册到AndroidManifest文件中"><a href="#3-定义Service，并注册到AndroidManifest文件中" class="headerlink" title="3.定义Service，并注册到AndroidManifest文件中"></a>3.定义Service，并注册到AndroidManifest文件中</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Service</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">TAG</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;MyService&quot;</span>;<br><br>    <span class="hljs-keyword">private</span> IMyAidlInterface.<span class="hljs-type">Stub</span> <span class="hljs-variable">mBinder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyAIDLImplement</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">()</span> &#123;<br>        LogUtils.d(TAG, <span class="hljs-string">&quot;MyService onCreate&quot;</span>);<br>        <span class="hljs-built_in">super</span>.onCreate();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> IBinder <span class="hljs-title function_">onBind</span><span class="hljs-params">(Intent intent)</span> &#123;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Return the communication channel to the service.</span><br>        <span class="hljs-keyword">return</span> mBinder;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAIDLImplement</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">IMyAidlInterface</span>.Stub &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getStudentId</span><span class="hljs-params">(String studentName)</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br>            <span class="hljs-keyword">if</span>(studentName.equals(<span class="hljs-string">&quot;Tom&quot;</span>)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">99</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>AndroidManifest.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">service</span></span><br><span class="hljs-tag">    //<span class="hljs-attr">指定ServiceName</span>，<span class="hljs-attr">需要和文件名一致</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.MyService&quot;</span></span><br><span class="hljs-tag">    //<span class="hljs-attr">控制组件是否禁用</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:enabled</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">     //<span class="hljs-attr">指定Service运行在单独进程中</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:process</span>=<span class="hljs-string">&quot;:myService&quot;</span></span><br><span class="hljs-tag">         //<span class="hljs-attr">Service组件是可以被其他应用访问的</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">service</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="4-客户端bind到service"><a href="#4-客户端bind到service" class="headerlink" title="4.客户端bind到service"></a>4.客户端bind到service</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//bind 到 service</span><br>binderServiceBtn.setOnClickListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">View</span>.OnClickListener() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View v)</span> &#123;<br>                <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(BinderActivity.<span class="hljs-built_in">this</span>, MyService.class);<br>                bindService(intent, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceConnection</span>() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onServiceConnected</span><span class="hljs-params">(ComponentName name, IBinder service)</span> &#123;<br>                        resultText.setText(<span class="hljs-string">&quot;service bind success&quot;</span>);<br>                        myAidlInterface = IMyAidlInterface.Stub.asInterface(service);<br>                    &#125;<br><br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onServiceDisconnected</span><span class="hljs-params">(ComponentName name)</span> &#123;<br>                        resultText.setText(<span class="hljs-string">&quot;client onServiceDisconnected name: &quot;</span> + name);<br>                    &#125;<br>                &#125;, BIND_AUTO_CREATE);<br>            &#125;<br>        &#125;);<br><br><br><span class="hljs-comment">//调用AIDL接口</span><br>getStudentID.setOnClickListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">View</span>.OnClickListener() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View v)</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">studentName</span> <span class="hljs-operator">=</span> studentNameEditText.getText().toString();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">studentID</span> <span class="hljs-operator">=</span> myAidlInterface.getStudentId(studentName);<br>                resultText.setText(studentName + <span class="hljs-string">&quot;&#x27;s id is &quot;</span> + studentID);<br>            &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>        &#125;<br>    &#125;);<br></code></pre></td></tr></table></figure><h5 id="5-IxxxInterface接口类图"><a href="#5-IxxxInterface接口类图" class="headerlink" title="5.  IxxxInterface接口类图"></a>5.  IxxxInterface接口类图</h5><p><img src="/./img/Android%20Binder%E9%80%9A%E4%BF%A1_image/image-20241214114505655.png" alt="Interface接口类图"></p><p><img src="/./img/Android%20Binder%E9%80%9A%E4%BF%A1_image/image-20241214114547257.png" alt="service和client端类"></p><h4 id="1-2-AIDL关键字"><a href="#1-2-AIDL关键字" class="headerlink" title="1.2 AIDL关键字"></a>1.2 AIDL关键字</h4><h5 id="1-onway"><a href="#1-onway" class="headerlink" title="1.onway"></a>1.onway</h5><p>oneway 关键字用于修饰远程调用的行为<strong>修饰方法</strong>，被oneway修饰了的方法不可以有返回值，也不可以有带out或inout的参数。<br>使用oneway时，<strong>远程调用不会阻塞；它只是发送事务数据并立即返回</strong>。接口的实现最终接收此调用时，是以正常远程调用形式将其作为来自 Binder 线程池的常规调用进行接收。</p><p>可以理解为是异步调用，不接受返回值。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">oneway void getStudentIdoneway(String studentName);<br></code></pre></td></tr></table></figure><h5 id="2-in，out，inout介绍"><a href="#2-in，out，inout介绍" class="headerlink" title="2.in，out，inout介绍"></a>2.in，out，inout介绍</h5><p>in、out、inout表示跨进程通信中数据的流向,<strong>用来修饰参数</strong>（基本数据类型默认是in，非基本数据类型可以使用其它数据流向out、inout）。</p><ol><li><p><code>in</code> 表示数据只能由客户端流向服务端。（表现为服务端修改此参数，不会影响客户端的对象）</p></li><li><p><code>out</code> 表示数据只能由服务端流向客户端。（表现为<strong>服务端收到的参数是空对象</strong>，并且服务端修改对象后客户端会同步变动）</p></li><li><p><code>inout </code>则表示数据可在服务端与客户端之间<strong>双向流通</strong>。（表现为服务端能接收到客户端传来的完整对象，并且服务端修改对象后客户端会同步变动）</p></li></ol><h4 id="1-3-双向通信的实现"><a href="#1-3-双向通信的实现" class="headerlink" title="1.3 双向通信的实现"></a>1.3 双向通信的实现</h4><p>上述方法实现了单向通信，客户端进行调用服务端进程中的方法，下面要实现一种双向通信。</p><p>客户端实现一个IBinder对象，传递给service端（service端预留了setCallback接口用于跨进程传递），服务端通过IBinder对象调用Client端的方法。</p><p><img src="/./img/Android%20Binder%E9%80%9A%E4%BF%A1_image/image-20250104205847801.png" alt="image-20250104205847801"></p><ol><li><p>定义ICallbackClient类对应的AIDL文件</p></li><li><p>make，生成对应的java文件</p></li><li><p>service端： 定义setCallback接口，参数类型为ICallbackClient类</p></li><li><p>client端： bindService成功后，调用setCallback接口，将已经实现的ICallbackClient实例传递给service端</p></li><li><p>service端： 获取到ICallbackClient实例的代理对象。</p></li><li><p>service端： 通过获取到代理对象进行跨进程通过。</p></li></ol><h4 id="1-4-Messenger"><a href="#1-4-Messenger" class="headerlink" title="1.4 Messenger"></a>1.4 Messenger</h4><p>Messenger是一种更简单的实现跨进程通信的方式，它的本质是对应AIDL的一层封装。详见：<a href="/2025/01/04/Messenger/" title="Messenger">Messenger</a></p><p>主要区别如下：</p><p><strong>1. Messenger:</strong></p><ul><li><strong>简单易用：</strong> 无需编写 <code>.aidl</code> 文件，使用 Message 对象传递数据。</li><li><strong>串行执行：</strong> 服务端按顺序处理客户端请求，不支持并发。</li><li><strong>轻量级：</strong> 适用于简单的进程间通信，数据量小、并发量低的场景。</li><li><strong>类似单行道：</strong> 所有车辆（请求）只能排队通过。</li></ul><p><strong>2. AIDL:</strong></p><ul><li><strong>功能强大：</strong> 支持定义接口、数据类型，实现远程方法调用 (RPC)。</li><li><strong>并行执行：</strong> 服务端可同时处理多个客户端请求，支持高并发。</li><li><strong>复杂性高：</strong> 需要编写 <code>.aidl</code> 文件，并处理线程同步等问题。</li><li><strong>类似多车道高速公路：</strong> 多辆车（请求）可以同时行驶。</li></ul><p><strong>选择依据：</strong></p><ul><li><strong>简单通信、低并发：</strong> 选择 Messenger。</li><li><strong>复杂通信、高并发、RPC：</strong> 选择 AIDL。</li></ul><h3 id="2-binder服务"><a href="#2-binder服务" class="headerlink" title="2.binder服务"></a>2.binder服务</h3>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binder</tag>
      
      <tag>AIDL</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
